type array

(* Classical Theory of Arrays *)

logic get : array, int -> int

logic set : array, int, int -> array

axiom a1:
forall a : array. forall i : int. forall v : int [set (a,i,v)].
  get (set (a,i,v), i) = v

axiom a2:
forall a : array. forall i, j : int. forall v : int [get (set (a,i,v), j) | get(a,j), set(a,i,v)].
  i = j or get (set (a,i,v), j) = get (a, j)

(* pas de bon trigger, il faudrait un literal a1 <> a2 *)
axiom a_ext:
forall a1, a2 : array [a1, a2].
 a1 = a2 or not (forall i : int [get(a1, i), get(a2, i)]. get(a1, i) = get(a2, i))

(* Axiomatization for Membership *)

logic mem : array, int -> prop

axiom a_mem_get : forall a : array. forall j : int [mem (a, get (a, j))]. mem (a, get (a, j))

axiom a_mem_set : forall a : array. forall i, v, w : int [mem (a, w), set (a, i, v) | mem (set (a, i, v), w) ].
	v <> w -> get (a, i) <> w -> mem (set (a, i, v), w) = mem (a, w)

(* Proof of Completeness:
   - Arrays are infinite, map an unknown integer outside max and
    sum to v.
   - We can get a model of a1, a2, a_mem by mapping every remaining element to an
      unknown integer v and assuming mem (a, v). *)

(* Axiomatization for Maximum *)

logic max : array, int, int -> int

axiom max_in:
forall a : array. forall i, j : int [max (a, i, j)].
    i <= j -> not (forall n : int [get (a, n)]. i <= n <= j -> max (a, i, j) <> get (a, n))

axiom max_def:
forall a : array. forall i, j, n : int [get (a, n), max (a, i, j)]. i <= n <= j -> get (a, n) <=  max (a, i, j)

(* Proof of Completeness:
    - Map every get in a max to any value v smaller than every get. This cannot lead to an
      inconsistency since a2 only deduces equalities between unknown terms and infos
     deduced by max_def are redundant.
    - Map every new max to the value of the maximum. Obviously infos deduced by max_in and
      max_def are redundant.
    NB. This proof is compatible with the construct for the proof of mem by choosing the same
             element v. *)

(* Axiomatization for Sum *)

logic sum : array, int, int -> int

axiom sum_init:
forall a : array. forall i : int [sum (a, i, i), get (a, i)]. sum (a, i, i) = get (a, i)

axiom sum_next_left:
forall a : array. forall i, j : int [sum (a, i, j), get (a, i)].
   j >  i -> sum (a, i, j) = get (a, i) + sum (a, i+1, j)

axiom sum_cut1:
forall a : array. forall i, j, k : int [sum (a, i, j), sum (a, i, k)].
   j > k >= i -> sum (a, i, j) = sum (a, i, k) + sum (a, k+1, j)

axiom sum_cut2:
forall a : array. forall i, j, k : int [sum (a, i, j), sum (a, k, j)].
   j >= k > i -> sum (a, i, j) = sum (a, i, k-1) + sum (a, k, j)

axiom sum_set1:
forall a : array. forall i, j, k, v : int [sum (a, i, j), set (a, k, v) | sum (set (a, k, v), i, j)].
   j >= k >=  i -> sum (set (a, k, v), i, j) + get(a,k) = v + sum (a, i, j)

axiom sum_set2:
forall a : array. forall i, j, k, v : int [sum (a, i, j), set (a, k, v) | sum (set (a, k, v), i, j)].
  j >= i ->  (k > j or  k < i)-> sum (set (a, k, v), i, j) = sum (a, i, j)

(* Additional Axioms for Sum+Mem *)

axiom sum_mem:
forall a : array. forall i : int [mem (a, sum (a, i, i))]. mem (a, sum (a, i, i))

axiom sum_next_right:
forall a : array. forall i, j : int [sum (a, i, j), get (a, j)].
   j >  i ->  get (a, i) = get (a, i)

(* Additional Axioms for Sum+Max *)

axiom sum_max_get :
forall a : array. forall i, j, k, l, m : int [sum (a, i, j), max (a, k, l), get (a, m)].
i <= m <= j -> k <= m <= l -> sum (a, m, m) = sum (a, m, m)

axiom sum_max1:
forall a : array. forall i, j, k, l : int [sum (a, i, j), max (a, k, l)].
i <= k <= j <= l ->
sum (a, k, j) <= (j - k + 1) * max (a, k, j)

axiom sum_max2:
forall a : array. forall i, j, k, l : int [sum (a, i, j), max (a, k, l)].
k <= i <= j <= l ->
sum (a, i, j) <= (j - i + 1) * max (a, i, j)

axiom sum_max3:
forall a : array. forall i, j, k, l : int [sum (a, i, j), max (a, k, l)].
i <= k <= l <= j ->
sum (a, k, l) <= (l - k + 1) * max (a, k, l)

axiom sum_max4:
forall a : array. forall i, j, k, l : int [sum (a, i, j), max (a, k, l)].
k <= i <= l <= j ->
sum (a, i, l) <= (i - l + 1) * max (a, i, l)
