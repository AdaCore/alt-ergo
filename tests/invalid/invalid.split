$$$ac_arith_mult

logic y:real
goal g1 : y*y = 9.1 -> -3. = y or  y = 3.

$
logic x:int
goal g2 : 4 <= x*x <= 9 -> 2 <= x <= 3

$

logic f : int -> int

(*bresenham_po_4 : risque de boucler si on relache
 Arith.color *)
goal g3 :
  forall a,b,x,y,z,t:int.
  x * x  = f(z) + 2 ->
  x * y = f(t) + 2 ->
  false

$
logic x:int
goal g4 : 0 <= x*x <= 4 -> 0 <= x <= 2

$
logic x:int
goal g5 : x*x = 25 -> x = 5


$$$arith_div

logic x,y:int
goal g1: 2 <= x / y <= 4 -> y = 2 -> 4 <= x <= 8

$
logic x,y:int
goal g2: 4 <= x <= 8 -> -2 <= y <= 2 -> -8 <= x / y <= 8

$
logic x,y:int
goal g3: 0 / 0 = 0

$
logic x,y:int
goal g4: -1 <= x <= 1 -> 0 / x = 0

$
logic x:int
goal g5 : x/x = 1 


$
logic x:int
goal g6 : 0/0 = 1 

$
logic x:int
goal g7 : 0/0 = 0/0 -> false

$
logic x:int
goal g8 : 0/0 <> 0/0

$
logic x:int
logic P,Q: int -> prop
goal g9 : P(0/x) -> P(0)

$
logic x:int
logic P,Q: int -> prop
goal g10 : P(0) -> P(x)




$$$arith
goal g1: 1=2
$
logic a:int
goal g2: a+0 = a+1
$
logic Q,P: prop

goal g3:
  forall c,v:int. (Q and c<=v and v<=c) ->P 
$
logic f: int -> int
goal g4: 
  forall x,y:int. f(x-1) = x + 2 and f(y) = y - 2 and y + 1 = x
$
logic f: int -> int
goal g5: 
  forall u,v,x,y:int.
  u<=v and v<=u and 2*x +1 <= 2*y and x=f(u) and y=f(v)
$
logic P: prop
goal g6: 
  forall x:int. x=1 and (3<x -> P) -> P
$
logic Q,P: prop
goal g7: 
  forall x:int. x=3 and (3<x -> P) -> P
$
logic b,a,c: int

goal g8:   b<=c -> (b<>a)-> a+1<=b  -> false
$
goal g9: forall x:int. 0<=x<=1 -> x=0
$
goal g10: forall x:int. 0<=x<=1 -> x=1
$

goal g11:
forall x,y:int.  9*x + 13*y + 1 = 0 -> false

$ goal g12:
 forall diff:int.
 forall left:int.
 forall right:int.
 diff = right - left ->
 diff > 0 ->
 forall r6:int. r6 = diff / 2 ->
 forall r8:int. r8 = left + r6 ->
 right - r8 < diff 

$
logic P : int -> prop

logic x,y : int
 
goal g13 : y = 0 -> P(x/y) -> false

$
logic x,y : int
 
goal g14 : -1 < x/y <1 -> false

$
logic x,y : int
 
goal g15 : x > 0 -> y > 0 -> x/y >0

$
logic x,y,z : int
 
goal g16 : x>=0 -> y >=0 -> x/y>=0

$

logic x,y,z : int
 
goal g17 : x>=0 -> y >=0 -> x/y = z -> y = 0 -> x/y>=0

$

logic a, b, c :int

goal g18:
 3*c -2 = 8*a and
 c  <= 0 and 
 - b - c  <= 0 and 
 2*b + c - 2  <= 0
 -> false


$$$bool
logic A,B : prop

goal g1: A -> (A -> not A)
$
logic A,B : prop
goal g2: A and not A
$
logic A,B : prop
goal g3: (A or B) and not A and not B
$
logic A,B : prop
goal g4: (A -> B) -> (not A -> not B)
$
logic A,B : prop
goal g5: (A -> B) -> (B -> A)
$
logic A,B : prop
goal g6: B -> (B and A)
$
logic A,B : prop
goal g7: (A -> A) <-> A
$
logic p , q : int -> prop 
goal g8: 
  (forall x:int. p(x) <-> q(x)) <-> 
  ((forall x:int. p(x)) <-> forall x:int. q(x))
$
logic a,b,c:prop
goal g9 : not ((a->(a or b or c) and (not a or not b or not c))
           and (b -> (a and b and c) or (not a and not b and not c))
           and (c -> a and b))
$
logic f : bool -> bool
axiom a: ((f(true) = true) <-> (true <> true)) 
goal g10: false

$$$list
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

goal g1 : forall x,y:int. hd(tl(cons(x, cons(y, nil)))) = x
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)

goal g2 : length(cons(1,cons(2,cons(3,nil)))) = 2

$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

goal g3 : nth(cons(1,cons(2,cons(3,nil))), 1) = 3
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)


(* mem *)


logic mem : 'a, 'a list -> prop


axiom mem_def_1 : 
  forall x:'a. not mem(x,nil)


axiom mem_def_2 : 
  forall x:'a. forall y:'a. forall l:'a list.
  mem(x, cons(y,l)) <-> (x = y or mem(x,l))


goal g4 : mem(2, cons(1,cons(5,cons(3,nil))))

$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

(* append *)

logic append : 'a list, 'a list -> 'a list

axiom append_def_1 : 
  forall l:'a list. append(nil,l) = l

axiom append_def_2 : 
  forall x:'a. forall l1,l2:'a list.
  append(cons(x,l1),l2) = cons(x,append(l1,l2))

goal g5 : 
  append(cons(1,cons(2,nil)), cons(3,cons(4,nil))) = 
  cons(1, cons(2, cons(4, nil)))
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)

logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

(* append *)

logic append : 'a list, 'a list -> 'a list

axiom append_def_1 : 
  forall l:'a list. append(nil,l) = l

axiom append_def_2 : 
  forall x:'a. forall l1,l2:'a list.
  append(cons(x,l1),l2) = cons(x,append(l1,l2))


(* rev *)

logic rev : 'a list -> 'a list

axiom rev_def_1 : rev(nil) = nil

axiom rev_def_2 : 
  forall x:'a. forall l:'a list.
  rev(cons(x,l)) = append(rev(l), cons(x,nil))

goal g6 : rev(cons(1,cons(2,nil))) = nil

$$$typage

axiom a2: forall x,y:unit [x,y]. x=y

goal g3: 1=2
$$$ac_arith
$
logic a,b,c,x,beta,gamma,d:int

logic ac f : int,int -> int

goal g1 : 
     f((f(a,b) + x),c) = gamma -> 
     x = 1 -> 
     f(a,c) = a -> 
     f(a,d) = beta -> 
     f(b,beta) = f(d,gamma)
     
$

logic a,b,c,gamma,beta,x : int
logic ac f : int , int -> int

goal g2 : 
  f(a,b) = f(x,gamma) ->
  f(a,c) = f(x,beta) ->
  f(gamma,c) = f(beta,b)

$

logic a,b,c,gamma,beta,x,u,v : int
logic f : int , int -> int

goal g3 : 
  f(a,b)     = u ->
  f(a,c)     = v ->
  f(x,gamma) = u ->
  f(x,beta)  = v ->
  f(gamma,c) = f(beta,b)

$

logic a,b,c,gamma,beta,x,y: int
logic ac f : int , int -> int

goal g4 : 
  f(a,b) = f(x,gamma) ->
  f(a,c) = f(x,beta) ->
  f(x,f(gamma,c)) = f(y,f(beta,b))

$$$ let

logic P : 'a, int -> prop

goal g : forall x:int. (let x=3 in P(x,x)) ->P(x,3)

$ 

type t
logic P : int -> prop
logic Q: t->prop

goal g6 : forall x:t. P(let x=3 in x+x) -> Q(x)


$$$arrays
logic t1,t2,t3,t4,t5 : int farray
logic P: 'a -> prop
logic x:int

axiom a : forall t1: 'a farray. forall i,j:int. forall v:'a.
  P(t1[i <- v, 2 <- 3, j <- v][0 <- 1][36])

goal g1 :
  t2 = t1[0 <- 2] ->
  t3 = t2[2 <- 2] ->
  t4 = t3[2 <- 3] ->
  t5 = t4[0 <- 1] ->
  x = t5[36] ->
    P(x)

$
logic t1,t2,t3: 'a farray
logic P: 'a,'b -> prop
type 'a t
logic x,y:int t
logic z : bool farray t

axiom a : forall t1: 'a farray. forall i,j:int. forall v,w:'a.
  P(t1[i <- v, 2 <- w][j <- v],z)

goal g2 :
  forall a,b:int.
  t2 = t1[a <- x] ->
  t3 = t2[2 <- y, b <- x] ->
    P(t3, z)



$$$exists

goal g : 
     (exists x:int. x=2) -> (exists x:int. x=3) -> false


$$$sum_poly_arrays
type t = A | B | C | D

goal g1 : forall a : ('a,t) farray.
     forall j : 'a. forall v : t.
     a[j] <> A and a[j] <> B
     and a[j] <> C and a[j] <> D


$$$explanations

logic A,B,C,D:prop
logic x,y,z:int

goal g1:
     A or B -> C or D -> (A -> C or A -> D)