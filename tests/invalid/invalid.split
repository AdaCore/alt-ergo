$$$ac_arith_mult

logic y:real
goal g1 : y*y = 9.1 -> -3. = y or  y = 3.

$
logic x:int
goal g2 : 4 <= x*x <= 9 -> 2 <= x <= 3

$

logic f : int -> int

(*bresenham_po_4 : risque de boucler si on relache
 Arith.color *)
goal g3 :
  forall a,b,x,y,z,t:int.
  x * x  = f(z) + 2 ->
  x * y = f(t) + 2 ->
  false

$
logic x:int
goal g4 : 0 <= x*x <= 4 -> 0 <= x <= 2

$
logic x:int
goal g5 : x*x = 25 -> x = 5


$$$arith_div

logic x,y:int
goal g1: 2 <= x / y <= 4 -> y = 2 -> 4 <= x <= 8

$
logic x,y:int
goal g2: 4 <= x <= 8 -> -2 <= y <= 2 -> -8 <= x / y <= 8

$
logic x,y:int
goal g3: 0 / 0 = 0

$
logic x,y:int
goal g4: -1 <= x <= 1 -> 0 / x = 0

$
logic x:int
goal g5 : x/x = 1 


$
logic x:int
goal g6 : 0/0 = 1 

$
logic x:int
goal g7 : 0/0 = 0/0 -> false

$
logic x:int
goal g8 : 0/0 <> 0/0

$
logic x:int
logic P,Q: int -> prop
goal g9 : P(0/x) -> P(0)

$
logic x:int
logic P,Q: int -> prop
goal g10 : P(0) -> P(x)

$
logic x,y:int
goal g11 : y >= 1 -> (x/y)*y = x




$$$arith
goal g1: 1=2
$
logic a:int
goal g2: a+0 = a+1
$
logic Q,P: prop

goal g3:
  forall c,v:int. (Q and c<=v and v<=c) ->P 
$
logic f: int -> int
goal g4: 
  forall x,y:int. f(x-1) = x + 2 and f(y) = y - 2 and y + 1 = x
$
logic f: int -> int
goal g5: 
  forall u,v,x,y:int.
  u<=v and v<=u and 2*x +1 <= 2*y and x=f(u) and y=f(v)
$
logic P: prop
goal g6: 
  forall x:int. x=1 and (3<x -> P) -> P
$
logic Q,P: prop
goal g7: 
  forall x:int. x=3 and (3<x -> P) -> P
$
logic b,a,c: int

goal g8:   b<=c -> (b<>a)-> a+1<=b  -> false
$
goal g9: forall x:int. 0<=x<=1 -> x=0
$
goal g10: forall x:int. 0<=x<=1 -> x=1
$

goal g11:
forall x,y:int.  9*x + 13*y + 1 = 0 -> false

$ goal g12:
 forall diff:int.
 forall left:int.
 forall right:int.
 diff = right - left ->
 diff > 0 ->
 forall r6:int. r6 = diff / 2 ->
 forall r8:int. r8 = left + r6 ->
 right - r8 < diff 

$
logic P : int -> prop

logic x,y : int
 
goal g13 : y = 0 -> P(x/y) -> false

$
logic x,y : int
 
goal g14 : -1 < x/y <1 -> false

$
logic x,y : int
 
goal g15 : x > 0 -> y > 0 -> x/y >0

$
logic x,y,z : int
 
goal g16 : x>=0 -> y >=0 -> x/y>=0

$

logic x,y,z : int
 
goal g17 : x>=0 -> y >=0 -> x/y = z -> y = 0 -> x/y>=0

$

logic a, b, c :int

goal g18:
 3*c -2 = 8*a and
 c  <= 0 and 
 - b - c  <= 0 and 
 2*b + c - 2  <= 0
 -> false

$
goal g19 : forall x,y,z,t:int.  30*x = 15*y + 10*z + t ->
     t = 5 -> false 

$
goal g20:
  forall a,min, max,k : int.
  min = a ->
  min <= k <= max ->
  max - min <= 10 ->
  max - min = 0 ->
  false 

$
goal g8 : forall x:real. x < 3.0 -> x <= 2.0

$
logic p:int

goal g5: 
(* 1 *) p <> 0 and p <> 1 and p <= 9 and
(*      p ∈ ]-∞; -1] U [2; 3] U [5; 9]          *)
(* 2 *) p >= 4 and p <= 10 and p <> 5 and
(*      p ∈ [4; 4] U [6; 10]          *)
(* 3 *) p >= 1 and p <= 4 -> false


$$$bool
logic A,B : prop

goal g1: A -> (A -> not A)
$
logic A,B : prop
goal g2: A and not A
$
logic A,B : prop
goal g3: (A or B) and not A and not B
$
logic A,B : prop
goal g4: (A -> B) -> (not A -> not B)
$
logic A,B : prop
goal g5: (A -> B) -> (B -> A)
$
logic A,B : prop
goal g6: B -> (B and A)
$
logic A,B : prop
goal g7: (A -> A) <-> A
$
logic p , q : int -> prop 
goal g8: 
  (forall x:int. p(x) <-> q(x)) <-> 
  ((forall x:int. p(x)) <-> forall x:int. q(x))
$
logic a,b,c:prop
goal g9 : not ((a->(a or b or c) and (not a or not b or not c))
           and (b -> (a and b and c) or (not a and not b and not c))
           and (c -> a and b))
$
logic f : bool -> bool
axiom a: ((f(true) = true) <-> (true <> true)) 
goal g10: false

$
logic A,B,C,D : prop
goal g11: (A or B or C) -> A

$
logic A,B,C,D : prop
goal g12: (A or B or C) -> B

$
logic A,B,C,D : prop
goal g13: (A or B or C) -> C

$
logic A,B,C,D : prop
goal g14: ((A -> D) or (B -> A) or (C -> B)) -> A -> D

$
logic A,B,C,D : prop
goal g15: ((A -> D) or (B -> A) or (C -> B)) -> (C -> D)

$
logic A,B,C,D : prop
goal g16: not ((A or B) -> (B or A))

$
logic p,q,r : prop
goal g17: (not ((p -> q) and (p and q -> r) -> (p -> r)))
$
logic A,B,C,P,Q,R,S: prop
goal g18: not (((A -> B) and A) -> B)
$
logic A,B,C,P,Q,R,S: prop
goal g19: not (((A -> B) and not B) -> not A)
$
logic A,B,C,P,Q,R,S: prop
goal g20: not (((A -> B) and (B -> C)) -> (A -> C))
$
logic A,B,C,P,Q,R,S: prop
goal g21: not ((A and (B or C)) -> ((A and B) or (A and C)))
$
logic A,B,C,P,Q,R,S: prop
goal g22: not (((A and B) or (A and C)) -> (A and (B or C)))
$
logic A,B,C,P,Q,R,S: prop
goal g23: not ((A or (B and C)) -> ((A or B) and (A or C)))
$
logic A,B,C,P,Q,R,S: prop
goal g24: not (((A or B) and (A or C)) -> (A or (B and C)))
$
logic A,B,C,P,Q,R,S: prop
goal g25: not ((not A -> A) -> A)
$
logic A,B,C,P,Q,R,S: prop
goal g26: not (((P -> (Q and R and S)) and not S) -> not P)

$
type bag

type btree

logic empty_tree :  -> btree

logic is_heap : btree -> prop

type 'a marray

logic access : 'a1 marray, int -> 'a1

logic update : 'a1 marray, int, 'a1 -> 'a1 marray

logic array_length : 'a1 marray -> int

logic tree_of_array : int marray, int, int -> btree

axiom tree_of_array_empty:
  (forall a:int marray.
    (forall root:int.
      (forall bound:int.
        (((bound <= root) or (root < 0)) -> (tree_of_array(a, root,
         bound) = empty_tree)))))


axiom div2: (forall i:int. ((0 < i) -> (((i - 1) / 2) < i)))

axiom div2gen:
  (forall i:int.
    (forall j:int. (((0 < i) and (i <= j)) -> (((i - 1) / 2) < j))))


goal correctness_HeapImpl_pop_po_27:
  forall size:int.
  forall t:int marray.
  ( 0 < array_length(t) and is_heap(tree_of_array(t, 0, size))) ->
  false





$$$list
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

goal g1 : forall x,y:int. hd(tl(cons(x, cons(y, nil)))) = x
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)

goal g2 : length(cons(1,cons(2,cons(3,nil)))) = 2

$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

goal g3 : nth(cons(1,cons(2,cons(3,nil))), 1) = 3
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)


(* mem *)


logic mem : 'a, 'a list -> prop


axiom mem_def_1 : 
  forall x:'a. not mem(x,nil)


axiom mem_def_2 : 
  forall x:'a. forall y:'a. forall l:'a list.
  mem(x, cons(y,l)) <-> (x = y or mem(x,l))


goal g4 : mem(2, cons(1,cons(5,cons(3,nil))))

$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

(* append *)

logic append : 'a list, 'a list -> 'a list

axiom append_def_1 : 
  forall l:'a list. append(nil,l) = l

axiom append_def_2 : 
  forall x:'a. forall l1,l2:'a list.
  append(cons(x,l1),l2) = cons(x,append(l1,l2))

goal g5 : 
  append(cons(1,cons(2,nil)), cons(3,cons(4,nil))) = 
  cons(1, cons(2, cons(4, nil)))
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)

logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

(* append *)

logic append : 'a list, 'a list -> 'a list

axiom append_def_1 : 
  forall l:'a list. append(nil,l) = l

axiom append_def_2 : 
  forall x:'a. forall l1,l2:'a list.
  append(cons(x,l1),l2) = cons(x,append(l1,l2))


(* rev *)

logic rev : 'a list -> 'a list

axiom rev_def_1 : rev(nil) = nil

axiom rev_def_2 : 
  forall x:'a. forall l:'a list.
  rev(cons(x,l)) = append(rev(l), cons(x,nil))

goal g6 : rev(cons(1,cons(2,nil))) = nil

$$$typage

axiom a2: forall x,y:unit [x,y]. x=y

goal g3: 1=2
$$$ac_arith
$
logic a,b,c,x,beta,gamma,d:int

logic ac f : int,int -> int

goal g1 : 
     f((f(a,b) + x),c) = gamma -> 
     x = 1 -> 
     f(a,c) = a -> 
     f(a,d) = beta -> 
     f(b,beta) = f(d,gamma)
     
$

logic a,b,c,gamma,beta,x : int
logic ac f : int , int -> int

goal g2 : 
  f(a,b) = f(x,gamma) ->
  f(a,c) = f(x,beta) ->
  f(gamma,c) = f(beta,b)

$

logic a,b,c,gamma,beta,x,u,v : int
logic f : int , int -> int

goal g3 : 
  f(a,b)     = u ->
  f(a,c)     = v ->
  f(x,gamma) = u ->
  f(x,beta)  = v ->
  f(gamma,c) = f(beta,b)

$

logic a,b,c,gamma,beta,x,y: int
logic ac f : int , int -> int

goal g4 : 
  f(a,b) = f(x,gamma) ->
  f(a,c) = f(x,beta) ->
  f(x,f(gamma,c)) = f(y,f(beta,b))

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g5 : 
  f(a+1,a) = f(a,b+1)

$
logic a,b,c,x,beta,gamma,d:int

logic ac f : int,int -> int

goal g6 : 
     f((f(a,b) + x),c) = gamma -> 
     f(a,c) = a -> 
     f(a,d) = beta -> 
     f(b,beta) = f(d,gamma)

$

logic ac f : int,int -> int
goal g7 : forall a,b,c,x:int. c = a + x  -> a = f(c,b) -> a=0 ->  f(c,b)=c

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g8 : 
  f(a+1,a) = f(a+1,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g9 : 
  a  = b -> 
  f(a+1,a) = f(a,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g10 : 
  a + 1 = b + x -> 
  x = b -> 
  f(a,a) = f(a,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g11 : 
  f(a,a) = a ->
  f(a,b) + a =a + b->
  a = b 

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g12 : 
  a + 1 = b + 1 -> 
  f(a,a-1) = f(a,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int
goal g13 : 
  2 * a = 3 * b -> 
  f(x,(2/3) * a) = f(b,x)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g15 : 
  f(b,a) = a ->
  f(a,b) + a = a + b

$

logic ac f : int,int -> int

goal g16 : (forall v,w:int[v,w]. f(v,w) = w) -> (exists v,w:int. v <> w)


$$$let

logic P : 'a, int -> prop

goal g : forall x:int. (let x=3 in P(x,x)) ->P(x,3)

$ 

type t
logic P : int -> prop
logic Q: t->prop

goal g6 : forall x:t. P(let x=3 in x+x) -> Q(x)


$$$arrays
logic t1,t2,t3,t4,t5 : int farray
logic P: 'a -> prop
logic x:int

axiom a : forall t1: 'a farray. forall i,j:int. forall v:'a.
  P(t1[i <- v, 2 <- 3, j <- v][0 <- 1][36])

goal g1 :
  t2 = t1[0 <- 2] ->
  t3 = t2[2 <- 2] ->
  t4 = t3[2 <- 3] ->
  t5 = t4[0 <- 1] ->
  x = t5[36] ->
    P(x)

$
logic t1,t2,t3: 'a farray
logic P: 'a,'b -> prop
type 'a t
logic x,y:int t
logic z : bool farray t

axiom a : forall t1: 'a farray. forall i,j:int. forall v,w:'a.
  P(t1[i <- v, 2 <- w][j <- v],z)

goal g2 :
  forall a,b:int.
  t2 = t1[a <- x] ->
  t3 = t2[2 <- y, b <- x] ->
    P(t3, z)



$$$exists

goal g1 : 
     (exists x:int. x=2) -> (exists x:int. x=3) -> false

$
goal g2 : 
     (exists x:int. x=2 and x=3)

$
logic P: int -> prop
goal g3 : 
     (exists x:int. P(x)) -> forall x:int. P(x)

$
logic P: int -> prop
goal g4 : 
     (exists x:int. P(x)) -> forall x:int. (exists y:int. x=y and P(y))


$$$sum_poly_arrays
type t = A | B | C | D

goal g1 : forall a : ('a,t) farray.
     forall j : 'a. forall v : t.
     a[j] <> A and a[j] <> B
     and a[j] <> C and a[j] <> D


$$$explanations

logic A,B,C,D:prop
logic x,y,z:int

goal g1:
     A or B -> C or D -> (A -> C or A -> D)


$$$quant

type 'a t
logic P,Q: 'a t -> prop

goal g1: forall y:int t. P(y) -> ((forall x:'a t. P(x) -> Q(x)) -> Q(y))

$
logic f : int -> int
logic g : int,int -> int
axiom a2 : forall x,y:int. let z = f(x) in  g(y,z) = 1
goal g2 : g(f(1), 2) = 1

$
type t

logic c : t
logic f : t -> t
logic p,q : t -> prop

goal g3 : (forall x:t. p(x) -> q(x)) -> q(c) -> p(c)



$$$cc
type t
logic a,b,c,d,e: t
logic f,h : 'a -> 'a
logic g: 'a , 'a -> 'a

goal g1: 
  forall x:t. h(x)=x and g(a,x)=a ->  g(g(x,g(a,h(x))),x)=a
$
type t
logic a,b,c,d,e,f: t
	
goal g2: 
  a=c and c=e and a<>b and b=f and d <> b -> c<>d
$
type t
logic a,b,c,d,e: t
logic f : 'a -> 'a
logic g,h: 'a , 'a -> 'a

goal g3: 
  forall x,y:t. f(f(f(a)))=a and f(f(f(f(f(f(a))))))=a and g(x,y)=x -> 
  h(g(g(x,y),y),a)=h(x,f(a))

$
logic P,Q: int -> prop
logic f: int -> int
axiom a : 
  forall x:int[P(f(x))]. 
    P(f(x)) -> Q(x)
goal g4:
      forall a,b,c:int.
    P(a) -> a= f(b) -> a = f(f(c)) ->
    Q(b) and Q(c)
