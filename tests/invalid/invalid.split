$$$ac_arith_mult

logic y:real
goal g1 : y*y = 9.1 -> -3. = y or  y = 3.

$
logic x:int
goal g2 : 4 <= x*x <= 9 -> 2 <= x <= 3

$

logic f : int -> int

(*bresenham_po_4 : risque de boucler si on relache
 Arith.color *)
goal g3 :
  forall a,b,x,y,z,t:int.
  x * x  = f(z) + 2 ->
  x * y = f(t) + 2 ->
  false

$
logic x:int
goal g4 : 0 <= x*x <= 4 -> 0 <= x <= 2

$
logic x:int
goal g5 : x*x = 25 -> x = 5




$$$arith_div

logic x,y:int
goal g1: 2 <= x / y <= 4 -> y = 2 -> 4 <= x <= 8

$
logic x,y:int
goal g2: 4 <= x <= 8 -> -2 <= y <= 2 -> -8 <= x / y <= 8

$
logic x,y:int
goal g3: 0 / 0 = 0

$
logic x,y:int
goal g4: -1 <= x <= 1 -> 0 / x = 0

$
logic x:int
goal g5 : x/x = 1 


$
logic x:int
goal g6 : 0/0 = 1 

$
logic x:int
goal g7 : 0/0 = 0/0 -> false

$
logic x:int
goal g8 : 0/0 <> 0/0

$
logic x:int
logic P,Q: int -> prop
goal g9 : P(0/x) -> P(0)

$
logic x:int
logic P,Q: int -> prop
goal g10 : P(0) -> P(x)

$
logic x,y:int
goal g11 : y >= 1 -> (x/y)*y = x

$
logic x,y:int
goal g12 :
     x = 5 -> y - (x / 10) = y - 1

$

logic x:int

goal g13:
 ((2 * x) - 1) % 2) - (((2 * x) - 1) % 2) <> 0

$

logic x,y:int

goal g14:
     (x / y) - (x / y) = 0 ->
     x / y = 1 ->
     false



$$$arith
goal g1: 1=2
$
logic a:int
goal g2: a+0 = a+1
$
logic Q,P: prop

goal g3:
  forall c,v:int. (Q and c<=v and v<=c) ->P 
$
logic f: int -> int
goal g4: 
  forall x,y:int. f(x-1) = x + 2 and f(y) = y - 2 and y + 1 = x
$
logic f: int -> int
goal g5: 
  forall u,v,x,y:int.
  u<=v and v<=u and 2*x +1 <= 2*y and x=f(u) and y=f(v)
$
logic P: prop
goal g6: 
  forall x:int. x=1 and (3<x -> P) -> P
$
logic Q,P: prop
goal g7: 
  forall x:int. x=3 and (3<x -> P) -> P
$
logic b,a,c: int

goal g8:   b<=c -> (b<>a)-> a+1<=b  -> false
$
goal g9: forall x:int. 0<=x<=1 -> x=0
$
goal g10: forall x:int. 0<=x<=1 -> x=1
$

goal g11:
forall x,y:int.  9*x + 13*y + 1 = 0 -> false

$ goal g12:
 forall diff:int.
 forall left:int.
 forall right:int.
 diff = right - left ->
 diff > 0 ->
 forall r6:int. r6 = diff / 2 ->
 forall r8:int. r8 = left + r6 ->
 right - r8 < diff 

$
logic P : int -> prop

logic x,y : int
 
goal g13 : y = 0 -> P(x/y) -> false

$
logic x,y : int
 
goal g14 : -1 < x/y <1 -> false

$
logic x,y : int
 
goal g15 : x > 0 -> y > 0 -> x/y >0

$
logic x,y,z : int
 
goal g16 : x>=0 -> y >=0 -> x/y>=0

$

logic x,y,z : int
 
goal g17 : x>=0 -> y >=0 -> x/y = z -> y = 0 -> x/y>=0

$

logic a, b, c :int

goal g18:
 3*c -2 = 8*a and
 c  <= 0 and 
 - b - c  <= 0 and 
 2*b + c - 2  <= 0
 -> false

$
goal g19 : forall x,y,z,t:int.  30*x = 15*y + 10*z + t ->
     t = 5 -> false 

$
goal g20:
  forall a,min, max,k : int.
  min = a ->
  min <= k <= max ->
  max - min <= 10 ->
  max - min = 0 ->
  false

$
goal g21: (-1) % 32 = -1

$
goal g22: (-1) % 32 < 0

$
goal g23: forall x:int. x= -1 -> x % (-32) = -33

$
goal g24: forall x,y:int. x= -1 -> x % (-32) = y -> false


$
goal g8 : forall x:real. x < 3.0 -> x <= 2.0

$
logic p:int

goal g5: 
(* 1 *) p <> 0 and p <> 1 and p <= 9 and
(*      p ∈ ]-∞; -1] U [2; 3] U [5; 9]          *)
(* 2 *) p >= 4 and p <= 10 and p <> 5 and
(*      p ∈ [4; 4] U [6; 10]          *)
(* 3 *) p >= 1 and p <= 4 -> false


$$$bool
logic A,B : prop

goal g1: A -> (A -> not A)
$
logic A,B : prop
goal g2: A and not A
$
logic A,B : prop
goal g3: (A or B) and not A and not B
$
logic A,B : prop
goal g4: (A -> B) -> (not A -> not B)
$
logic A,B : prop
goal g5: (A -> B) -> (B -> A)
$
logic A,B : prop
goal g6: B -> (B and A)
$
logic A,B : prop
goal g7: (A -> A) <-> A
$
logic p , q : int -> prop 
goal g8: 
  (forall x:int. p(x) <-> q(x)) <-> 
  ((forall x:int. p(x)) <-> forall x:int. q(x))
$
logic a,b,c:prop
goal g9 : not ((a->(a or b or c) and (not a or not b or not c))
           and (b -> (a and b and c) or (not a and not b and not c))
           and (c -> a and b))
$
logic f : bool -> bool
axiom a: ((f(true) = true) <-> (true <> true)) 
goal g10: false

$
logic A,B,C,D : prop
goal g11: (A or B or C) -> A

$
logic A,B,C,D : prop
goal g12: (A or B or C) -> B

$
logic A,B,C,D : prop
goal g13: (A or B or C) -> C

$
logic A,B,C,D : prop
goal g14: ((A -> D) or (B -> A) or (C -> B)) -> A -> D

$
logic A,B,C,D : prop
goal g15: ((A -> D) or (B -> A) or (C -> B)) -> (C -> D)

$
logic A,B,C,D : prop
goal g16: not ((A or B) -> (B or A))

$
logic p,q,r : prop
goal g17: (not ((p -> q) and (p and q -> r) -> (p -> r)))
$
logic A,B,C,P,Q,R,S: prop
goal g18: not (((A -> B) and A) -> B)
$
logic A,B,C,P,Q,R,S: prop
goal g19: not (((A -> B) and not B) -> not A)
$
logic A,B,C,P,Q,R,S: prop
goal g20: not (((A -> B) and (B -> C)) -> (A -> C))
$
logic A,B,C,P,Q,R,S: prop
goal g21: not ((A and (B or C)) -> ((A and B) or (A and C)))
$
logic A,B,C,P,Q,R,S: prop
goal g22: not (((A and B) or (A and C)) -> (A and (B or C)))
$
logic A,B,C,P,Q,R,S: prop
goal g23: not ((A or (B and C)) -> ((A or B) and (A or C)))
$
logic A,B,C,P,Q,R,S: prop
goal g24: not (((A or B) and (A or C)) -> (A or (B and C)))
$
logic A,B,C,P,Q,R,S: prop
goal g25: not ((not A -> A) -> A)
$
logic A,B,C,P,Q,R,S: prop
goal g26: not (((P -> (Q and R and S)) and not S) -> not P)

$
type bag

type btree

logic empty_tree :  -> btree

logic is_heap : btree -> prop

type 'a marray

logic access : 'a1 marray, int -> 'a1

logic update : 'a1 marray, int, 'a1 -> 'a1 marray

logic array_length : 'a1 marray -> int

logic tree_of_array : int marray, int, int -> btree

axiom tree_of_array_empty:
  (forall a:int marray.
    (forall root:int.
      (forall bound:int.
        (((bound <= root) or (root < 0)) -> (tree_of_array(a, root,
         bound) = empty_tree)))))


axiom div2: (forall i:int. ((0 < i) -> (((i - 1) / 2) < i)))

axiom div2gen:
  (forall i:int.
    (forall j:int. (((0 < i) and (i <= j)) -> (((i - 1) / 2) < j))))


goal correctness_HeapImpl_pop_po_27:
  forall size:int.
  forall t:int marray.
  ( 0 < array_length(t) and is_heap(tree_of_array(t, 0, size))) ->
  false





$$$list
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

goal g1 : forall x,y:int. hd(tl(cons(x, cons(y, nil)))) = x
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)

goal g2 : length(cons(1,cons(2,cons(3,nil)))) = 2

$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

goal g3 : nth(cons(1,cons(2,cons(3,nil))), 1) = 3
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)


(* mem *)


logic mem : 'a, 'a list -> prop


axiom mem_def_1 : 
  forall x:'a. not mem(x,nil)


axiom mem_def_2 : 
  forall x:'a. forall y:'a. forall l:'a list.
  mem(x, cons(y,l)) <-> (x = y or mem(x,l))


goal g4 : mem(2, cons(1,cons(5,cons(3,nil))))

$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)



logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

(* append *)

logic append : 'a list, 'a list -> 'a list

axiom append_def_1 : 
  forall l:'a list. append(nil,l) = l

axiom append_def_2 : 
  forall x:'a. forall l1,l2:'a list.
  append(cons(x,l1),l2) = cons(x,append(l1,l2))

goal g5 : 
  append(cons(1,cons(2,nil)), cons(3,cons(4,nil))) = 
  cons(1, cons(2, cons(4, nil)))
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list
logic hd : 'a list -> 'a
logic tl : 'a list -> 'a list

axiom hd_cons : forall x:'a. forall l:'a list. hd (cons(x,l)) = x
axiom tl_cons : forall x:'a. forall l:'a list. tl (cons(x,l)) = l

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

axiom length_def_2 : 
  forall x:'a. forall l:'a list. 
  length(cons(x,l)) = 1 + length(l)

logic nth : 'a list, int -> 'a

axiom nth_def_1 : 
  forall x:'a. forall l:'a list. nth(cons(x,l),0) = x

axiom nth_def_2 : 
  forall x:'a. forall l:'a list. forall n:int.
  n > 0 -> nth(cons(x,l),n) = nth(l,n-1)

(* append *)

logic append : 'a list, 'a list -> 'a list

axiom append_def_1 : 
  forall l:'a list. append(nil,l) = l

axiom append_def_2 : 
  forall x:'a. forall l1,l2:'a list.
  append(cons(x,l1),l2) = cons(x,append(l1,l2))


(* rev *)

logic rev : 'a list -> 'a list

axiom rev_def_1 : rev(nil) = nil

axiom rev_def_2 : 
  forall x:'a. forall l:'a list.
  rev(cons(x,l)) = append(rev(l), cons(x,nil))

goal g6 : rev(cons(1,cons(2,nil))) = nil

$$$typage

axiom a2: forall x,y:unit [x,y]. x=y

goal g3: 1=2
$$$ac_arith
$
logic a,b,c,x,beta,gamma,d:int

logic ac f : int,int -> int

goal g1 : 
     f((f(a,b) + x),c) = gamma -> 
     x = 1 -> 
     f(a,c) = a -> 
     f(a,d) = beta -> 
     f(b,beta) = f(d,gamma)
     
$

logic a,b,c,gamma,beta,x : int
logic ac f : int , int -> int

goal g2 : 
  f(a,b) = f(x,gamma) ->
  f(a,c) = f(x,beta) ->
  f(gamma,c) = f(beta,b)

$

logic a,b,c,gamma,beta,x,u,v : int
logic f : int , int -> int

goal g3 : 
  f(a,b)     = u ->
  f(a,c)     = v ->
  f(x,gamma) = u ->
  f(x,beta)  = v ->
  f(gamma,c) = f(beta,b)

$

logic a,b,c,gamma,beta,x,y: int
logic ac f : int , int -> int

goal g4 : 
  f(a,b) = f(x,gamma) ->
  f(a,c) = f(x,beta) ->
  f(x,f(gamma,c)) = f(y,f(beta,b))

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g5 : 
  f(a+1,a) = f(a,b+1)

$
logic a,b,c,x,beta,gamma,d:int

logic ac f : int,int -> int

goal g6 : 
     f((f(a,b) + x),c) = gamma -> 
     f(a,c) = a -> 
     f(a,d) = beta -> 
     f(b,beta) = f(d,gamma)

$

logic ac f : int,int -> int
goal g7 : forall a,b,c,x:int. c = a + x  -> a = f(c,b) -> a=0 ->  f(c,b)=c

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g8 : 
  f(a+1,a) = f(a+1,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g9 : 
  a  = b -> 
  f(a+1,a) = f(a,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g10 : 
  a + 1 = b + x -> 
  x = b -> 
  f(a,a) = f(a,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g11 : 
  f(a,a) = a ->
  f(a,b) + a =a + b->
  a = b 

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g12 : 
  a + 1 = b + 1 -> 
  f(a,a-1) = f(a,b)

$

logic a,b,c,x:int
logic ac f : int,int -> int
goal g13 : 
  2 * a = 3 * b -> 
  f(x,(2/3) * a) = f(b,x)

$

logic a,b,c,x:int
logic ac f : int,int -> int

goal g15 : 
  f(b,a) = a ->
  f(a,b) + a = a + b

$

logic ac f : int,int -> int

goal g16 : (forall v,w:int[v,w]. f(v,w) = w) -> (exists v,w:int. v <> w)


$$$arrays
logic t1,t2,t3,t4,t5 : int farray
logic P: 'a -> prop
logic x:int

axiom a : forall t1: 'a farray. forall i,j:int. forall v:'a.
  P(t1[i <- v, 2 <- 3, j <- v][0 <- 1][36])

goal g1 :
  t2 = t1[0 <- 2] ->
  t3 = t2[2 <- 2] ->
  t4 = t3[2 <- 3] ->
  t5 = t4[0 <- 1] ->
  x = t5[36] ->
    P(x)

$
logic t1,t2,t3: 'a farray
logic P: 'a,'b -> prop
type 'a t
logic x,y:int t
logic z : bool farray t

axiom a : forall t1: 'a farray. forall i,j:int. forall v,w:'a.
  P(t1[i <- v, 2 <- w][j <- v],z)

goal g2 :
  forall a,b:int.
  t2 = t1[a <- x] ->
  t3 = t2[2 <- y, b <- x] ->
    P(t3, z)

$
goal g3:
  forall t1: int farray.
  t1[1<-1,2<-2,3<-3,4<-4,5<-5,6<-6,1<-2,7<-7,8<-8,9<-9,10<-10][1] = 1

$
goal g4:
  forall t1: int farray.
  forall x1, x2: int.
  t1[x1<-1,x2<-2][x1] = 1

$
goal g5:
  forall i,j:int.
  forall v : 'a.
  forall a,b : 'a farray.
  a[i] = a[j<-v][i]

$

goal g6 :
  forall i,j:int.
  forall v : 'a.
  forall a,b : 'a farray.
  i = 1 -> 
  b = a[j<-v] ->
  a[i] = b[i]

$

goal g7 :
  forall i,j:int.
  forall v : 'a.
  forall a,b : 'a farray.
  v = a[j<-v][i]

$

goal g8 :
  forall i,j:int.
  forall v : 'a.
  forall a,b : 'a farray.
  b = a[j<-v] ->
  v = b[i]

$
goal g9 :
  forall i,j:int.
  forall v : 'a.
  forall a,b : 'a farray.
  a = b ->
  b = b[j <- a[i]]

$
goal g10 :
  forall i,j,k:int.
  forall v,w : 'a.
  forall b : 'a farray.
  i = 1 ->
  j = 2 -> 
  b = b[j<-b[i],k<-w] ->
  b[i] = b[j]


$
goal g11 :
  forall i,j:int.
  forall v1,v2 : 'a.
  forall a : 'a farray.
  i = 1 ->
  a[i<-v1, j<-v2] = a[j<-v2, i<-v1]


$
goal g12:
  forall i,j:int.
  forall v,w : 'a.
  forall a,b : 'a farray.
  a = b -> 
  b = b[j<-v, i<-w]->
  a[j]= v

$
goal g13:
  forall i,j:int.
  forall a,b : int farray.
  a=b ->
  a[i] = b[i<-a[j]][i]

$
goal g14 :
  forall i,j:int.
  forall v1,v2 : 'a.
  forall a : 'a farray.
  a[i<-v1, j<-v2] = a[j<-v2, i<-v1]

$
goal g15 :
  forall a1,a2,a3,a4,b1,b2 : int farray.
  forall i1,i2,i3,e1,e2,e3,e4,e5,e6,k:int.
  a1=b1[i1<-e1] ->
  a2=b2[i1<-e2] ->
  a3=a1[i2<-e3] ->
  a4=a2[i2<-e4] ->
  e1=b2[i1] ->
  e2=b1[i1] ->
  e3=a2[i2] ->
  e4=a1[i2] ->
  b2[i3] = b1[i3]


$
logic t1,t2 : int farray

axiom a : forall t1,t2 : 'a farray.
  forall a,b:int.
   t1[a+b] = t2[a-b]

goal g16 : forall x,y:int. t1[3+x] = t2[x]


$$$poly_arrays

type a
logic fi : int -> a
logic ti : a -> int

goal g1:
  forall t1: (a,int) farray.
  t1[fi(1)<-1,
     fi(2)<-2,fi(3)<-3,fi(4)<-4,fi(5)<-5,
     fi(6)<-6,fi(7)<-7,fi(8)<-8,fi(9)<-9,
     fi(10)<-10][fi(1)] = 1

$
type a
logic fi : int -> a
logic ti : a -> int

goal g2:
  forall t1: (a,int) farray.
  t1[fi(1)<-1,
     fi(2)<-2,fi(3)<-3,fi(4)<-4,fi(5)<-5,
     fi(6)<-6,fi(7)<-7,fi(8)<-8,fi(9)<-9,
     fi(10)<-10][fi(5)] = 5

$
goal g3 :
  forall i,j:'a.
  forall v : 'b.
  forall a,b : ('a,'b) farray.
  v = a[j<-v][i]

$
goal g4 :
  forall i,j:'a.
  forall v : 'b.
  forall b : ('a,'b) farray.
  b = b[j <- b[i]]

$
goal g5:
  forall a,b : ('a,'b) farray.
  forall i,j : 'a.
  forall v,w : 'b.
  v = a[j] ->
  w = b[i] ->
  a[j<-w] = b[i<-v] ->
  a[j] = b[j]



$$$injective

type a
logic fi : 'b -> a
logic ti : a -> 'b

axiom Inj : forall x :a. ti(fi(x))=x

goal inj : exists x,y:a. fi(x)=fi(y) -> x <> y


$$$exists

goal g1 : 
     (exists x:int. x=2) -> (exists x:int. x=3) -> false

$
goal g2 : 
     (exists x:int. x=2 and x=3)

$
logic P: int -> prop
goal g3 : 
     (exists x:int. P(x)) -> forall x:int. P(x)

$
logic P: int -> prop
goal g4 : 
     (exists x:int. P(x)) -> forall x:int. (exists y:int. x=y and P(y))


$$$sum_poly_arrays
type t = A | B | C | D

goal g1 : forall a : ('a,t) farray.
     forall j : 'a. forall v : t.
     a[j] <> A and a[j] <> B
     and a[j] <> C and a[j] <> D


$$$explanations

logic A,B,C,D : prop
goal g1: ((A -> D) or (B -> A) or (C -> B)) -> A -> D

$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

logic mem : 'a, 'a list -> prop


axiom mem_def_2 : 
  forall x:'a. forall y:'a. forall l:'a list.
  mem(x, cons(y,l))  <->   (x = y or mem(x,l))

goal g2 : 2 = 1 or mem(2, nil)

$
logic x, a: int
logic p,q,r : prop

goal g3 : 
a<5 -> (x *a > 6 or r) ->  (x=1 or x*a<=2) -> (x = -1 or a*x>5) -> (p or q) -> false

$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g4 : 
a<5 -> (x *a + y > 6 or r) ->  ((x=1  and y =0) or x*a<=2) -> ((x = -1 and y = 0)or a*x>5) -> (p or q) -> false

$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g5 : 
a<5 -> (x *a + y > 6 or r) ->  (x=1  or x*a+y<=2) -> ((x=1  and y =0) or x*a<=2) ->(x = -1 or a*x+y>5) ->  (p or q) -> false

$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g6 : 
(x=1  or x*a+y<=2) -> ((x=1  and y =0) or x*a<=2) -> a<5 -> (x *a + y > 6 or r) ->(x = -1 or a*x+y>5) ->  (p or q) -> false

$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g7 : 
(x=1  or x*a+y<=2) -> (p or q) -> ((x=1  and y =0) or x*a<=2) -> (x *a + y > 6 or r) ->(x = -1 or a*x+y>5) ->  a<5 -> false

$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g9 : 
a<5 -> (r or x *a + y > 6) ->  (x*a+y<=2 or x=1) -> ((x=1  and y =0) or x*a<=2) ->(a*x+y>5 or x = -1) ->  (p or q) -> false


$$$quant

type 'a t
logic P,Q: 'a t -> prop

goal g1: forall y:int t. P(y) -> ((forall x:'a t. P(x) -> Q(x)) -> Q(y))

$
logic f : int -> int
logic g : int,int -> int
axiom a2 : forall x,y:int. let z = f(x) in  g(y,z) = 1
goal g2 : g(f(1), 2) = 1

$
type t

logic c : t
logic f : t -> t
logic p,q : t -> prop

goal g3 : (forall x:t. p(x) -> q(x)) -> q(c) -> p(c)



$$$cc
type t
logic a,b,c,d,e: t
logic f,h : 'a -> 'a
logic g: 'a , 'a -> 'a

goal g1: 
  forall x:t. h(x)=x and g(a,x)=a ->  g(g(x,g(a,h(x))),x)=a
$
type t
logic a,b,c,d,e,f: t
	
goal g2: 
  a=c and c=e and a<>b and b=f and d <> b -> c<>d
$
type t
logic a,b,c,d,e: t
logic f : 'a -> 'a
logic g,h: 'a , 'a -> 'a

goal g3: 
  forall x,y:t. f(f(f(a)))=a and f(f(f(f(f(f(a))))))=a and g(x,y)=x -> 
  h(g(g(x,y),y),a)=h(x,f(a))

$
logic P,Q: int -> prop
logic f: int -> int
axiom a : 
  forall x:int[P(f(x))]. 
    P(f(x)) -> Q(x)
goal g4:
      forall a,b,c:int.
    P(a) -> a= f(b) -> a = f(f(c)) ->
    Q(b) and Q(c)



$$$bitv

goal g1: [|10|]=[|01|]
$
goal g2: [|10|]@[|01|]=[|1010|]
$
goal g3: [|10|]@[|01|]=[|0|]@[|1|]@[|01|]
$
goal g4: [|01|]=[|1001|]^{2,3}
$
goal g5: [|010|]^{1,2}=[|1100|]^{1,2}
$
goal g6: forall x:bitv[3].  x^{0,1} = [|01|]
$
goal g7: forall x,y:bitv[2]. x=[|10|] -> y=[|01|] -> y@x=[|1001|]
$
goal g8: forall x:bitv[4]. forall y:bitv[2]. 
         x=y@[|11|] -> x^{2,3}=[|10|] -> x=[|1110|]
$
goal g9: forall x,y:bitv[2]. x^{0,0} = y^{0,0}
$
goal g10: forall x,y:bitv[2].  x = y
$
logic f : 'a -> bitv[2]

goal g11: forall x:bitv[3]. forall y:bitv[2]. forall z:'a.
          x=y@[|1|] -> f(z)=y -> f(z)^{0,0} = x^{0,0}


$$$let

goal g1: 
     let x = 3 in let y = 1 in x = y

$

goal g2: 
     let x = 3 in x+x = 5

$ 

goal g3: 
     let x = 3 in x=2

$

type t
logic P : t, int -> prop

goal g4 : forall x:t. forall y:int. (let y=3 in P(x,y)) -> P(x,y)

$
logic P : int -> prop

goal g5 : forall y:int. P(let y=4 in y+y) -> P(y)

$
goal g6 : let x = 1 in let x = 2 in x = 1

$
goal g7 : forall x:int. x = (let x = 2 in x)

$
goal g8 : let x = 1 in x = (let x = 2 in x)

$
logic P : 'a, int -> prop

goal g9 : forall x:int. (let x=3 in P(x,x)) ->P(x,3)

$ 

type t
logic P : int -> prop
logic Q: t->prop

goal g10 : forall x:t. P(let x=3 in x+x) -> Q(x)


$$$predicate
logic f : int -> prop
logic r : int -> prop

predicate p (x : int) = f(x)

axiom a : forall x : int [p(x)]. p(x) -> r (x)

goal g1 : forall a : int. f(a) -> r(a+1)



$$$sum

type t = A | B | C

goal g1: 
  A = B or B = C or A = C 
    
$
type t = A | B | C

goal g2:
forall x:t. x <> A -> x = B

$
type t = A | B | C

goal g3:
  forall x:t. x = A -> x = B

$
type t = A | B | C

goal g4:
  forall x:t.
  x <> A -> x <> B -> x <> C

$
type t = A | B | C

goal g5:
  exists x:t. x <> A and x <> B and x <> C

$
type t = A | B | C

goal g6:
  forall x:t. (x = A or x = B)
$

type t = A | B | C

goal g7:
  forall x:t. x <> A

$

type t = A | B

logic f: t , int -> int

goal g8:
  exists x:t.
  exists y:int.
  f(x,y) = f(A,y) and f(x,y) = f(B,y)

    
$$$sum_poly_arrays
type t = A | B | C | D

goal g1 :
     forall a : (t,int) farray.
     a[A <- 1, B <- 2][C] = 1

$
type t = A | B | C | D
type t2 = E | F | G | H

goal g2 :
     forall a : (t,t2) farray.
     a[B <- E][A] <> E ->
     a[C <- F][A] <> F ->
     a[D <- G][A] <> F ->
     a[A] = H


$$$polymorphism

type 'a t
logic P,P': int -> prop
logic Q,S: 'a t -> prop
logic Q': int, int -> prop
logic R: prop
logic a: bool t

logic b: int t

axiom a3: forall x:'a t. S(x) -> (forall y:'a t. Q(y))

goal g3: S(a) -> Q(b)