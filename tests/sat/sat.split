$$$sat
$cobj:La fonctionnalité à vérifier est que le SAT solveur d'Alt-Ergo est exécuté correctement sur un problème propositionel.

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g1: A or not A

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g2: A -> not not A

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g3: A -> A

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g4: ((A -> B) -> A) -> A

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g5: (A -> B)-> (not B -> not A)

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g6: ((A -> B) and A) -> B

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g7: ((A -> B) and not B) -> not A

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g8: ((A -> B) and (B -> C)) -> (A -> C)

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g9: (A and (B or C)) -> ((A and B) or (A and C))

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g10: ((A and B) or (A and C)) -> (A and (B or C))

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g11: (A or (B and C)) -> ((A or B) and (A or C))

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g12: ((A or B) and (A or C)) -> (A or (B and C))

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g13: (not A -> A) -> A 

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g14: ((P -> (Q and R and S)) and not S) -> not P

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g15: (P and Q) -> (Q and P)

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g16: (A and A) or not A

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g17: not not A <-> A

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
(* De morgan *)
goal g18: not(A and B) <-> (not A or not B)

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g19: not(A or B) <-> (not A and not B)

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
(* Distributivite *)
goal g20: (A or (B and C)) <-> ((A or B) and (A or C))

$res:Valid
$
logic A,B,C,P,Q,R,S: prop
goal g21: (A and (B or C)) <-> ((A and B) or (A and C))


$res:Valid
$
logic A,B,C,D : prop
goal g22: (A or B) -> (B or A)


$res:Valid
$
logic p,q,r : prop
goal g23: (p -> q) and (p and q -> r) -> (p -> r)






$$$sat_false
$cobj:La fonctionnalité à vérifier est que le SAT solveur d'Alt-Ergo est exécuté correctement sur un problème propositionel, explore bien toutes les branches nécéssaires et ne prouve pas \texttt{false}.


$res:I don't know
$
logic A,B : prop
goal g1: A -> (A -> not A)

$res:I don't know
$
logic A,B : prop
goal g2: A and not A

$res:I don't know
$
logic A,B : prop
goal g3: (A or B) and not A and not B

$res:I don't know
$
logic A,B : prop
goal g4: (A -> B) -> (not A -> not B)

$res:I don't know
$
logic A,B : prop
goal g5: (A -> B) -> (B -> A)

$res:I don't know
$
logic A,B : prop
goal g6: B -> (B and A)

$res:I don't know
$
logic A,B : prop
goal g7: (A -> A) <-> A

$res:I don't know
$
logic p , q : int -> prop 
goal g8: 
  (forall x:int. p(x) <-> q(x)) <-> 
  ((forall x:int. p(x)) <-> forall x:int. q(x))

$res:I don't know
$
logic a,b,c:prop
goal g9 : not ((a->(a or b or c) and (not a or not b or not c))
           and (b -> (a and b and c) or (not a and not b and not c))
           and (c -> a and b))

$res:I don't know
$
logic f : bool -> bool
axiom a: ((f(true) = true) <-> (true <> true)) 
goal g10: false


$res:I don't know
$
logic A,B,C,D : prop
goal g11: (A or B or C) -> A


$res:I don't know
$
logic A,B,C,D : prop
goal g12: (A or B or C) -> B


$res:I don't know
$
logic A,B,C,D : prop
goal g13: (A or B or C) -> C


$res:I don't know
$
logic A,B,C,D : prop
goal g14: ((A -> D) or (B -> A) or (C -> B)) -> A -> D


$res:I don't know
$
logic A,B,C,D : prop
goal g15: ((A -> D) or (B -> A) or (C -> B)) -> (C -> D)


$res:I don't know
$
logic A,B,C,D : prop
goal g16: not ((A or B) -> (B or A))


$res:I don't know
$
logic p,q,r : prop
goal g17: (not ((p -> q) and (p and q -> r) -> (p -> r)))

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g18: not (((A -> B) and A) -> B)

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g19: not (((A -> B) and not B) -> not A)

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g20: not (((A -> B) and (B -> C)) -> (A -> C))

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g21: not ((A and (B or C)) -> ((A and B) or (A and C)))

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g22: not (((A and B) or (A and C)) -> (A and (B or C)))

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g23: not ((A or (B and C)) -> ((A or B) and (A or C)))

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g24: not (((A or B) and (A or C)) -> (A or (B and C)))

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g25: not ((not A -> A) -> A)

$res:I don't know
$
logic A,B,C,P,Q,R,S: prop
goal g26: not (((P -> (Q and R and S)) and not S) -> not P)


$$$backjumping
$cobj:La fonctionnalité à vérifier est que le SAT solveur d'Alt-Ergo est exécuté correctement sur un problème propositionel, que le backjumping est correct et ne prouve pas \texttt{false}.


$res:I don't know
$
type bag

type btree

logic empty_tree :  -> btree

logic is_heap : btree -> prop

type 'a marray

logic access : 'a1 marray, int -> 'a1

logic update : 'a1 marray, int, 'a1 -> 'a1 marray

logic array_length : 'a1 marray -> int

logic tree_of_array : int marray, int, int -> btree

axiom tree_of_array_empty:
  (forall a:int marray.
    (forall root:int.
      (forall bound:int.
        (((bound <= root) or (root < 0)) -> (tree_of_array(a, root,
         bound) = empty_tree)))))


axiom div2: (forall i:int. ((0 < i) -> (((i - 1) / 2) < i)))

axiom div2gen:
  (forall i:int.
    (forall j:int. (((0 < i) and (i <= j)) -> (((i - 1) / 2) < j))))


goal correctness_HeapImpl_pop_po_27:
  forall size:int.
  forall t:int marray.
  ( 0 < array_length(t) and is_heap(tree_of_array(t, 0, size))) ->
  false

$res:I don't know
$
logic A,B,C,D : prop
goal g1: ((A -> D) or (B -> A) or (C -> B)) -> A -> D


$res:I don't know
$
type 'a list

logic nil : 'a list
logic cons : 'a, 'a list -> 'a list

logic length : 'a list -> int

axiom length_def_1 : length(nil) = 0

logic mem : 'a, 'a list -> prop


axiom mem_def_2 : 
  forall x:'a. forall y:'a. forall l:'a list.
  mem(x, cons(y,l))  <->   (x = y or mem(x,l))

goal g2 : 2 = 1 or mem(2, nil)




$res:I don't know
$
logic x, a: int
logic p,q,r : prop

goal g3 : 
 a<5 -> (x *a > 6 or r) ->
 (x=1 or x*a<=2) ->
 (x = -1 or a*x>5) -> 
 (p or q) -> false



$res:I don't know
$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g4 : 
  a<5 -> (x *a + y > 6 or r) ->
  ((x=1  and y =0) or x*a<=2) ->
  ((x = -1 and y = 0)or a*x>5) ->
  (p or q) ->
  false



$res:I don't know
$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g5 : 
  a<5 -> (x *a + y > 6 or r) ->
  (x=1  or x*a+y<=2) ->
  ((x=1  and y =0) or x*a<=2) ->
  (x = -1 or a*x+y>5) ->
  (p or q) -> false



$res:I don't know
$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g6 : 
  (x=1  or x*a+y<=2) ->
  ((x=1  and y =0) or x*a<=2) ->
  a<5 -> (x *a + y > 6 or r) ->
  (x = -1 or a*x+y>5) ->
  (p or q) -> false



$res:I don't know
$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g7 : 
 (x=1  or x*a+y<=2) ->
 (p or q) -> 
 ((x=1  and y =0) or x*a<=2) ->
 (x *a + y > 6 or r) ->
 (x = -1 or a*x+y>5) ->
 a<5 -> false



$res:I don't know
$
logic x, a,b,c,d,y: int
logic p,q,r : prop

goal g9 : 
   a<5 -> (r or x *a + y > 6) ->
   (x*a+y<=2 or x=1) ->
   ((x=1  and y =0) or x*a<=2) ->
   (a*x+y>5 or x = -1) ->  
   (p or q) -> false

