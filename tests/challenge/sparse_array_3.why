(* this is a prelude for Alt-Ergo*)
(* this is a prelude for Alt-Ergo integer arithmetic *)
axiom tuple0_inversion : (forall u:unit. (u = void))

type unit1

type qtmark

logic at : 'a, qtmark -> 'a

logic old : 'a -> 'a

logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

logic index_bool : bool -> int

axiom index_bool_True : (index_bool(true) = 0)

axiom index_bool_False : (index_bool(false) = 1)

axiom bool_inversion : (forall u:bool. ((u = true) or (u = false)))

function andb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, true,
  false), false)

function orb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  true, false))

function xorb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, false,
  true), match_bool(x, true, false))

function notb(x: bool) : bool = match_bool(x, false, true)

function implb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  false, true))

axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

logic const : 'b -> ('a,'b) farray

axiom Const : (forall b:'b. forall a:'a. ((const(b)[a]) = b))

type 'a array1

logic mk_array : int, (int,'a) farray -> 'a array1

logic mk_array_proj_1 : 'a array1 -> int

axiom mk_array_proj_1_def :
  (forall u:int. forall u1:(int,'a) farray. (mk_array_proj_1(mk_array(u,
  u1)) = u))

logic mk_array_proj_2 : 'a array1 -> (int,'a) farray

axiom mk_array_proj_2_def :
  (forall u:int. forall u1:(int,'a) farray. (mk_array_proj_2(mk_array(u,
  u1)) = u1))

axiom array_inversion :
  (forall u:'a array1. (u = mk_array(mk_array_proj_1(u),
  mk_array_proj_2(u))))

function elts(u: 'a array1) : (int,'a) farray = mk_array_proj_2(u)

function length(u: 'a array1) : int = mk_array_proj_1(u)

function get(a: 'a array1, i: int) : 'a = (elts(a)[i])

function set(a: 'a array1, i: int, v: 'a) : 'a array1 =
  mk_array(mk_array_proj_1(a), (elts(a)[i <- v]))

type 'a sparse_array

logic mk_sparse_array : 'a array1, int array1, int array1, int,
  'a -> 'a sparse_array

logic mk_sparse_array_proj_1 : 'a sparse_array -> 'a array1

axiom mk_sparse_array_proj_1_def :
  (forall u:'a array1. forall u1:int array1. forall u2:int array1.
  forall u3:int. forall u4:'a. (mk_sparse_array_proj_1(mk_sparse_array(u, u1,
  u2, u3, u4)) = u))

logic mk_sparse_array_proj_2 : 'a sparse_array -> int array1

axiom mk_sparse_array_proj_2_def :
  (forall u:'a array1. forall u1:int array1. forall u2:int array1.
  forall u3:int. forall u4:'a. (mk_sparse_array_proj_2(mk_sparse_array(u, u1,
  u2, u3, u4)) = u1))

logic mk_sparse_array_proj_3 : 'a sparse_array -> int array1

axiom mk_sparse_array_proj_3_def :
  (forall u:'a array1. forall u1:int array1. forall u2:int array1.
  forall u3:int. forall u4:'a. (mk_sparse_array_proj_3(mk_sparse_array(u, u1,
  u2, u3, u4)) = u2))

logic mk_sparse_array_proj_4 : 'a sparse_array -> int

axiom mk_sparse_array_proj_4_def :
  (forall u:'a array1. forall u1:int array1. forall u2:int array1.
  forall u3:int. forall u4:'a. (mk_sparse_array_proj_4(mk_sparse_array(u, u1,
  u2, u3, u4)) = u3))

logic mk_sparse_array_proj_5 : 'a sparse_array -> 'a

axiom mk_sparse_array_proj_5_def :
  (forall u:'a array1. forall u1:int array1. forall u2:int array1.
  forall u3:int. forall u4:'a. (mk_sparse_array_proj_5(mk_sparse_array(u, u1,
  u2, u3, u4)) = u4))

axiom sparse_array_inversion :
  (forall u:'a sparse_array. (u = mk_sparse_array(mk_sparse_array_proj_1(u),
  mk_sparse_array_proj_2(u), mk_sparse_array_proj_3(u),
  mk_sparse_array_proj_4(u), mk_sparse_array_proj_5(u))))

function back(u: 'a sparse_array) : int array1 = mk_sparse_array_proj_3(u)

function card(u: 'a sparse_array) : int = mk_sparse_array_proj_4(u)

function def(u: 'a sparse_array) : 'a = mk_sparse_array_proj_5(u)

function index(u: 'a sparse_array) : int array1 = mk_sparse_array_proj_2(u)

function values(u: 'a sparse_array) : 'a array1 = mk_sparse_array_proj_1(u)

predicate is_elt(a: 'a sparse_array, i: int) = (((0 <= get(index(a), i)) and
  (get(index(a), i) <  card(a))) and (get(back(a), get(index(a), i)) = i))

logic value : 'a sparse_array, int -> 'a

axiom value_def :
  (forall a:'a sparse_array. forall i:int. (is_elt(a, i) -> (value(a,
  i) = get(values(a), i))))

axiom value_def1 :
  (forall a:'a sparse_array. forall i:int. ((not is_elt(a, i)) -> (value(a,
  i) = def(a))))

function length1(a: 'a sparse_array) : int = length(values(a))

predicate sa_inv(a: 'a sparse_array) = ((((0 <= card(a)) and
  (card(a) <= length1(a))) and (length1(a) <= 1000)) and
  (((length(values(a)) = length(index(a))) and
  (length(index(a)) = length(back(a)))) and
  (forall i:int. (((0 <= i) and (i <  card(a))) -> (((0 <= get(back(a),
  i)) and (get(back(a), i) <  length1(a))) and (get(index(a), get(back(a),
  i)) = i))))))

predicate injective(a: (int,int) farray, n: int) =
  (forall i:int. forall j:int. (((0 <= i) and (i <  n)) -> (((0 <= j) and
  (j <  n)) -> ((not (i = j)) -> (not ((a[i]) = (a[j])))))))

predicate surjective(a: (int,int) farray, n: int) =
  (forall i:int. (((0 <= i) and (i <  n)) ->
  (exists j:int. (((0 <= j) and (j <  n)) and ((a[j]) = i)))))

predicate range(a: (int,int) farray, n: int) =
  (forall i:int. (((0 <= i) and (i <  n)) -> ((0 <= (a[i])) and
  ((a[i]) <  n))))

axiom injective_surjective :
  (forall a:(int,int) farray. forall n:int. (injective(a, n) -> (range(a,
  n) -> surjective(a, n))))

axiom permutation :
  (forall a:'a sparse_array. (sa_inv(a) -> ((card(a) = length1(a)) ->
  (forall i:int. (((0 <= i) and (i <  length1(a))) -> is_elt(a, i))))))

goal WP_parameter_set :
  (forall a:int. forall a1:int. forall a2:int. forall a3:'a.
  (forall i:int.
  (forall v:'a.
  (forall rho:int.
  (forall rho1:(int,int) farray.
  (forall rho2:(int,int) farray.
  (forall rho3:(int,'a) farray. ((((0 <= i) and (i <  a)) and
  sa_inv(mk_sparse_array(mk_array(a, rho3), mk_array(a1, rho2), mk_array(a2,
  rho1), rho, a3))) -> (((0 <= i) and (i <  a)) ->
  (forall x:(int,'a) farray. ((x = (rho3[i <- v])) -> ((((0 <= i) and
  (i <  a)) and sa_inv(mk_sparse_array(mk_array(a, x), mk_array(a1, rho2),
  mk_array(a2, rho1), rho, a3))) ->
  (forall result:bool. (((result = true) <->
  is_elt(mk_sparse_array(mk_array(a, x), mk_array(a1, rho2), mk_array(a2,
  rho1), rho, a3), i)) -> ((not (result = true)) -> ((rho <  a) ->
  (((0 <= i) and (i <  a1)) ->
  (forall x1:(int,int) farray. ((x1 = (rho2[i <- rho])) -> (((0 <= rho) and
  (rho <  a2)) ->
  (forall x2:(int,int) farray. ((x2 = (rho1[rho <- i])) ->
  (forall rho4:int. ((rho4 = (rho + 1)) ->
  (forall j:int. ((not (j = i)) -> (value(mk_sparse_array(mk_array(a, x),
  mk_array(a1, x1), mk_array(a2, x2), rho4, a3),
  j) = value(mk_sparse_array(mk_array(a, rho3), mk_array(a1, rho2),
  mk_array(a2, rho1), rho, a3), j))))))))))))))))))))))))))))

