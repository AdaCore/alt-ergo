(* this is a prelude for Alt-Ergo*)
(* this is a prelude for Alt-Ergo integer arithmetic *)
type 'a ghost

logic match_bool : bool, 'a1, 'a1 -> 'a1


axiom match_bool_True :
  (forall z:'a1. forall z1:'a1. (match_bool(true, z, z1) = z))


axiom match_bool_False :
  (forall z:'a1. forall z1:'a1. (match_bool(false, z, z1) = z1))


logic index_bool : bool -> int


axiom index_bool_True : (index_bool(true) = 0)


axiom index_bool_False : (index_bool(false) = 1)


axiom bool_inversion : (forall u:bool. ((u = true) or (u = false)))


function andb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, true,
  false), false)


function orb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  true, false))


function xorb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, false,
  true), match_bool(x, true, false))


function notb(x: bool) : bool = match_bool(x, false, true)


axiom tuple0_inversion : (forall u:unit. (u = void))


type unit1

logic ignore : 'a2 -> unit


type label_

logic at : 'a3, label_ -> 'a3


logic old : 'a4 -> 'a4


axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))


type ('a5,
'b) t

logic get : ('a6, 'b1) t, 'a6 -> 'b1


logic set : ('a7, 'b2) t, 'a7, 'b2 -> ('a7, 'b2) t


axiom Select_eq :
  (forall m:('a8, 'b3) t.
  (forall a1:'a8. forall a2:'a8.
  (forall b:'b3 [get(set(m, a1, b), a2)]. ((a1 = a2) -> (get(set(m, a1, b),
  a2) = b)))))


axiom Select_neq :
  (forall m:('a9, 'b4) t.
  (forall a1:'a9. forall a2:'a9.
  (forall b:'b4 [get(set(m, a1, b), a2)]. ((not (a1 = a2)) -> (get(set(m, a1,
  b), a2) = get(m, a2))))))


logic create_const : 'b5 -> ('a10, 'b5) t


axiom Const : (forall b:'b6. forall a:'a11. (get(create_const(b), a) = b))


type 'a12 map

logic length : (int, 'a13) t -> int


axiom Length_non_negative : (forall a:(int, 'a14) t. (0 <= length(a)))


axiom Length_set :
  (forall a:(int, 'a15) t.
  (forall k:int. (forall v:'a15. (length(set(a, k, v)) = length(a)))))


logic create_const_length : 'a16, int -> (int, 'a16) t


axiom Create_const_length_get :
  (forall b:'a17.
  (forall n:int. forall i:int. (get(create_const_length(b, n), i) = b)))


axiom Create_const_length_length :
  (forall a:'a18.
  (forall n:int. ((0 <= n) -> (length(create_const_length(a, n)) = n))))


logic create_length : int -> (int, 'a19) t


axiom Create_length_length :
  (forall n:int. ((0 <= n) -> (length(create_length(n)) = n)))


type 'a20 array1

predicate eq_board(b1: (int, int) t, b2: (int, int) t, pos: int) =
  (forall q:int. (((0 <= q) and (q <  pos)) -> (get(b1, q) = get(b2, q))))

axiom eq_board_set :
  (forall b:(int, int) t. forall pos:int. forall q:int. forall i:int.
  ((pos <= q) -> eq_board(b, set(b, q, i), pos)))


axiom eq_board_sym :
  (forall b1:(int, int) t. forall b2:(int, int) t. forall pos:int.
  (eq_board(b1, b2, pos) -> eq_board(b2, b1, pos)))


axiom eq_board_trans :
  (forall b1:(int, int) t. forall b2:(int, int) t. forall b3:(int, int) t.
  forall pos:int. (eq_board(b1, b2, pos) -> (eq_board(b2, b3, pos) ->
  eq_board(b1, b3, pos))))


axiom eq_board_extension :
  (forall b1:(int, int) t. forall b2:(int, int) t. forall pos:int.
  (eq_board(b1, b2, pos) -> ((get(b1, pos) = get(b2, pos)) -> eq_board(b1,
  b2, (pos + 1)))))


predicate consistent_row(board: (int, int) t, pos: int, q: int) =
  ((not (get(board, q) = get(board, pos))) and ((not ((get(board,
  q) - get(board, pos)) = (pos - q))) and (not ((get(board, pos) - get(board,
  q)) = (pos - q)))))

axiom consistent_row_eq :
  (forall b1:(int, int) t. forall b2:(int, int) t. forall pos:int.
  (eq_board(b1, b2, (pos + 1)) ->
  (forall q:int. (((0 <= q) and (q <  pos)) -> (consistent_row(b1, pos, q) ->
  consistent_row(b2, pos, q))))))


predicate is_consistent(board: (int, int) t, pos: int) =
  (forall q:int. (((0 <= q) and (q <  pos)) -> consistent_row(board, pos,
  q)))

axiom is_consistent_eq :
  (forall b1:(int, int) t. forall b2:(int, int) t. forall pos:int.
  (eq_board(b1, b2, (pos + 1)) -> (is_consistent(b1, pos) ->
  is_consistent(b2, pos))))


predicate is_board(board: (int, int) t, pos: int) =
  (forall q:int. (((0 <= q) and (q <  pos)) -> ((0 <= get(board, q)) and
  (get(board, q) <  length(board)))))

predicate solution(board: (int, int) t, pos: int) = (is_board(board, pos) and
  (forall q:int. (((0 <= q) and (q <  pos)) -> is_consistent(board, q))))

axiom solution_eq_board :
  (forall b1:(int, int) t. forall b2:(int, int) t. forall pos:int.
  ((length(b1) = length(b2)) -> (eq_board(b1, b2, pos) -> (solution(b1,
  pos) -> solution(b2, pos)))))


goal WP_bt_queens :
  (forall n:int.
  (forall pos:int.
  (forall board:(int, int) t. (((length(board) = n) and (((0 <= pos) and
  (pos <= n)) and solution(board, pos))) -> ((not (pos = n)) ->
  ((0 <= (n - 1)) ->
  (forall board1:(int, int) t.
  (forall i:int. (((0 <= i) and (i <= (n - 1))) -> (((length(board1) = n) and
  (eq_board(board1, board, pos) and
  (forall b:(int, int) t. ((length(b) = n) -> (is_board(b, n) ->
  (eq_board(board1, b, pos) -> (((0 <= get(b, pos)) and (get(b,
  pos) <  i)) -> (not solution(b, n))))))))) -> (((0 <= pos) and
  (pos <  length(board1))) ->
  (forall board2:(int, int) t. ((board2 = set(board1, pos, i)) ->
  (eq_board(board2, board, pos) -> (((0 <= pos) and
  (pos <  length(board2))) ->
  (forall result:bool. (((result = true) <-> is_consistent(board2, pos)) ->
  ((result = true) -> (((0 <= (n - pos)) and
  ((n - (pos + 1)) <  (n - pos))) and ((length(board2) = n) and
  (((0 <= (pos + 1)) and ((pos + 1) <= n)) and solution(board2,
  (pos + 1)))))))))))))))))))))))
