(* this is a prelude for Alt-Ergo*)
(* this is a prelude for Alt-Ergo integer arithmetic *)
type ident

axiom ident_eq_dec :
  (forall i1:ident. forall i2:ident. ((i1 = i2) or (not (i1 = i2))))

logic mk_ident : int -> ident

axiom mk_ident_inj :
  (forall i:int. forall j:int. ((mk_ident(i) = mk_ident(j)) -> (i = j)))

type operator

logic Oplus : operator

logic Ominus : operator

logic Omult : operator

logic match_operator : operator, 'a, 'a, 'a -> 'a

axiom match_operator_Oplus :
  (forall z:'a. forall z1:'a. forall z2:'a. (match_operator(Oplus, z, z1,
  z2) = z))

axiom match_operator_Ominus :
  (forall z:'a. forall z1:'a. forall z2:'a. (match_operator(Ominus, z, z1,
  z2) = z1))

axiom match_operator_Omult :
  (forall z:'a. forall z1:'a. forall z2:'a. (match_operator(Omult, z, z1,
  z2) = z2))

logic index_operator : operator -> int

axiom index_operator_Oplus : (index_operator(Oplus) = 0)

axiom index_operator_Ominus : (index_operator(Ominus) = 1)

axiom index_operator_Omult : (index_operator(Omult) = 2)

axiom operator_inversion :
  (forall u:operator. (((u = Oplus) or (u = Ominus)) or (u = Omult)))

type expr

logic Econst : int -> expr

logic Evar : ident -> expr

logic Ebin : expr, operator, expr -> expr

logic match_expr : expr, 'a, 'a, 'a -> 'a

axiom match_expr_Econst :
  (forall z:'a. forall z1:'a. forall z2:'a. forall u:int.
  (match_expr(Econst(u), z, z1, z2) = z))

axiom match_expr_Evar :
  (forall z:'a. forall z1:'a. forall z2:'a. forall u:ident.
  (match_expr(Evar(u), z, z1, z2) = z1))

axiom match_expr_Ebin :
  (forall z:'a. forall z1:'a. forall z2:'a. forall u:expr.
  forall u1:operator. forall u2:expr. (match_expr(Ebin(u, u1, u2), z, z1,
  z2) = z2))

logic index_expr : expr -> int

axiom index_expr_Econst :
  (forall u:int [Econst(u)]. (index_expr(Econst(u)) = 0))

axiom index_expr_Evar : (forall u:ident [Evar(u)]. (index_expr(Evar(u)) = 1))

axiom index_expr_Ebin :
  (forall u:expr. forall u1:operator. forall u2:expr [Ebin(u, u1, u2)].
  (index_expr(Ebin(u, u1, u2)) = 2))

logic Econst_proj_1 : expr -> int

axiom Econst_proj_1_def : (forall u:int. (Econst_proj_1(Econst(u)) = u))

logic Evar_proj_1 : expr -> ident

axiom Evar_proj_1_def : (forall u:ident. (Evar_proj_1(Evar(u)) = u))

logic Ebin_proj_1 : expr -> expr

axiom Ebin_proj_1_def :
  (forall u:expr. forall u1:operator. forall u2:expr. (Ebin_proj_1(Ebin(u,
  u1, u2)) = u))

logic Ebin_proj_2 : expr -> operator

axiom Ebin_proj_2_def :
  (forall u:expr. forall u1:operator. forall u2:expr. (Ebin_proj_2(Ebin(u,
  u1, u2)) = u1))

logic Ebin_proj_3 : expr -> expr

axiom Ebin_proj_3_def :
  (forall u:expr. forall u1:operator. forall u2:expr. (Ebin_proj_3(Ebin(u,
  u1, u2)) = u2))

axiom expr_inversion :
  (forall u:expr. (((u = Econst(Econst_proj_1(u))) or
  (u = Evar(Evar_proj_1(u)))) or (u = Ebin(Ebin_proj_1(u), Ebin_proj_2(u),
  Ebin_proj_3(u)))))

type stmt

logic Sskip : stmt

logic Sassign : ident, expr -> stmt

logic Sseq : stmt, stmt -> stmt

logic Sif : expr, stmt, stmt -> stmt

logic Swhile : expr, stmt -> stmt

logic match_stmt : stmt, 'a, 'a, 'a, 'a, 'a -> 'a

axiom match_stmt_Sskip :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  (match_stmt(Sskip, z, z1, z2, z3, z4) = z))

axiom match_stmt_Sassign :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall u:ident. forall u1:expr. (match_stmt(Sassign(u, u1), z, z1, z2, z3,
  z4) = z1))

axiom match_stmt_Sseq :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall u:stmt. forall u1:stmt. (match_stmt(Sseq(u, u1), z, z1, z2, z3,
  z4) = z2))

axiom match_stmt_Sif :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall u:expr. forall u1:stmt. forall u2:stmt. (match_stmt(Sif(u, u1, u2),
  z, z1, z2, z3, z4) = z3))

axiom match_stmt_Swhile :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall u:expr. forall u1:stmt. (match_stmt(Swhile(u, u1), z, z1, z2, z3,
  z4) = z4))

logic index_stmt : stmt -> int

axiom index_stmt_Sskip : (index_stmt(Sskip) = 0)

axiom index_stmt_Sassign :
  (forall u:ident. forall u1:expr [Sassign(u, u1)]. (index_stmt(Sassign(u,
  u1)) = 1))

axiom index_stmt_Sseq :
  (forall u:stmt. forall u1:stmt [Sseq(u, u1)]. (index_stmt(Sseq(u,
  u1)) = 2))

axiom index_stmt_Sif :
  (forall u:expr. forall u1:stmt. forall u2:stmt [Sif(u, u1, u2)].
  (index_stmt(Sif(u, u1, u2)) = 3))

axiom index_stmt_Swhile :
  (forall u:expr. forall u1:stmt [Swhile(u, u1)]. (index_stmt(Swhile(u,
  u1)) = 4))

logic Sassign_proj_1 : stmt -> ident

axiom Sassign_proj_1_def :
  (forall u:ident. forall u1:expr. (Sassign_proj_1(Sassign(u, u1)) = u))

logic Sassign_proj_2 : stmt -> expr

axiom Sassign_proj_2_def :
  (forall u:ident. forall u1:expr. (Sassign_proj_2(Sassign(u, u1)) = u1))

logic Sseq_proj_1 : stmt -> stmt

axiom Sseq_proj_1_def :
  (forall u:stmt. forall u1:stmt. (Sseq_proj_1(Sseq(u, u1)) = u))

logic Sseq_proj_2 : stmt -> stmt

axiom Sseq_proj_2_def :
  (forall u:stmt. forall u1:stmt. (Sseq_proj_2(Sseq(u, u1)) = u1))

logic Sif_proj_1 : stmt -> expr

axiom Sif_proj_1_def :
  (forall u:expr. forall u1:stmt. forall u2:stmt. (Sif_proj_1(Sif(u, u1,
  u2)) = u))

logic Sif_proj_2 : stmt -> stmt

axiom Sif_proj_2_def :
  (forall u:expr. forall u1:stmt. forall u2:stmt. (Sif_proj_2(Sif(u, u1,
  u2)) = u1))

logic Sif_proj_3 : stmt -> stmt

axiom Sif_proj_3_def :
  (forall u:expr. forall u1:stmt. forall u2:stmt. (Sif_proj_3(Sif(u, u1,
  u2)) = u2))

logic Swhile_proj_1 : stmt -> expr

axiom Swhile_proj_1_def :
  (forall u:expr. forall u1:stmt. (Swhile_proj_1(Swhile(u, u1)) = u))

logic Swhile_proj_2 : stmt -> stmt

axiom Swhile_proj_2_def :
  (forall u:expr. forall u1:stmt. (Swhile_proj_2(Swhile(u, u1)) = u1))

axiom stmt_inversion :
  (forall u:stmt. (((((u = Sskip) or (u = Sassign(Sassign_proj_1(u),
  Sassign_proj_2(u)))) or (u = Sseq(Sseq_proj_1(u), Sseq_proj_2(u)))) or
  (u = Sif(Sif_proj_1(u), Sif_proj_2(u), Sif_proj_3(u)))) or
  (u = Swhile(Swhile_proj_1(u), Swhile_proj_2(u)))))

axiom check_skip : (forall s:stmt. ((s = Sskip) or (not (s = Sskip))))

logic const : 'b -> ('a,'b) farray

axiom Const : (forall b:'b. forall a:'a. ((const(b)[a]) = b))

axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

type state

function eval_bin(x: int, op: operator, y: int) : int = match_operator(op,
  (x + y), (x - y), (x * y))

logic eval_expr : (ident,int) farray, expr -> int

axiom eval_expr_def :
  (forall s:(ident,int) farray.
  (forall x:int. (eval_expr(s, Econst(x)) = x)))

axiom eval_expr_def1 :
  (forall s:(ident,int) farray.
  (forall x:ident. (eval_expr(s, Evar(x)) = (s[x]))))

axiom eval_expr_def2 :
  (forall s:(ident,int) farray.
  (forall x:expr. forall x1:operator. forall x2:expr. (eval_expr(s, Ebin(x,
  x1, x2)) = eval_bin(eval_expr(s, x), x1, eval_expr(s, x2)))))

logic one_step : (ident,int) farray, stmt, (ident,int) farray, stmt -> prop

axiom one_step_assign :
  (forall s:(ident,int) farray. forall x:ident. forall e:expr. one_step(s,
  Sassign(x, e), (s[x <- eval_expr(s, e)]), Sskip))

axiom one_step_seq :
  (forall s:(ident,int) farray. forall sqt:(ident,int) farray.
  forall i1:stmt. forall i1qt:stmt. forall i2:stmt. (one_step(s, i1, sqt,
  i1qt) -> one_step(s, Sseq(i1, i2), sqt, Sseq(i1qt, i2))))

axiom one_step_seq_skip :
  (forall s:(ident,int) farray. forall i:stmt. one_step(s, Sseq(Sskip, i), s,
  i))

axiom one_step_if_true :
  (forall s:(ident,int) farray. forall e:expr. forall i1:stmt.
  forall i2:stmt. ((not (eval_expr(s, e) = 0)) -> one_step(s, Sif(e, i1, i2),
  s, i1)))

axiom one_step_if_false :
  (forall s:(ident,int) farray. forall e:expr. forall i1:stmt.
  forall i2:stmt. ((eval_expr(s, e) = 0) -> one_step(s, Sif(e, i1, i2), s,
  i2)))

axiom one_step_while_true :
  (forall s:(ident,int) farray. forall e:expr. forall i:stmt.
  ((not (eval_expr(s, e) = 0)) -> one_step(s, Swhile(e, i), s, Sseq(i,
  Swhile(e, i)))))

axiom one_step_while_false :
  (forall s:(ident,int) farray. forall e:expr. forall i:stmt. ((eval_expr(s,
  e) = 0) -> one_step(s, Swhile(e, i), s, Sskip)))

axiom one_step_inversion :
  (forall z:(ident,int) farray. forall z1:stmt. forall z2:(ident,int) farray.
  forall z3:stmt. (one_step(z, z1, z2, z3) ->
  (((((((exists s:(ident,int) farray. exists x:ident. exists e:expr.
        ((((z = s) and (z1 = Sassign(x, e))) and (z2 = (s[x <- eval_expr(s,
        e)]))) and (z3 = Sskip))) or
  (exists s:(ident,int) farray. exists sqt:(ident,int) farray.
  exists i1:stmt. exists i1qt:stmt. exists i2:stmt. (one_step(s, i1, sqt,
  i1qt) and ((((z = s) and (z1 = Sseq(i1, i2))) and (z2 = sqt)) and
  (z3 = Sseq(i1qt, i2)))))) or
  (exists s:(ident,int) farray. exists i:stmt. ((((z = s) and
  (z1 = Sseq(Sskip, i))) and (z2 = s)) and (z3 = i)))) or
  (exists s:(ident,int) farray. exists e:expr. exists i1:stmt.
  exists i2:stmt. ((not (eval_expr(s, e) = 0)) and ((((z = s) and
  (z1 = Sif(e, i1, i2))) and (z2 = s)) and (z3 = i1))))) or
  (exists s:(ident,int) farray. exists e:expr. exists i1:stmt.
  exists i2:stmt. ((eval_expr(s, e) = 0) and ((((z = s) and (z1 = Sif(e, i1,
  i2))) and (z2 = s)) and (z3 = i2))))) or
  (exists s:(ident,int) farray. exists e:expr. exists i:stmt.
  ((not (eval_expr(s, e) = 0)) and ((((z = s) and (z1 = Swhile(e, i))) and
  (z2 = s)) and (z3 = Sseq(i, Swhile(e, i))))))) or
  (exists s:(ident,int) farray. exists e:expr. exists i:stmt. ((eval_expr(s,
  e) = 0) and ((((z = s) and (z1 = Swhile(e, i))) and (z2 = s)) and
  (z3 = Sskip)))))))

goal If42 :
  (forall s1:(ident,int) farray. forall s2:(ident,int) farray. forall i:stmt.
  (one_step(const(0), Sif(Evar(mk_ident(0)), Sassign(mk_ident(0),
  Econst(13)), Sassign(mk_ident(0), Econst(42))), s1, i) -> (one_step(s1, i,
  s2, Sskip) -> ((s2[mk_ident(0)]) = 42))))

