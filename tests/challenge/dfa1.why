(* this is a prelude for Alt-Ergo*)
(* this is a prelude for Alt-Ergo integer arithmetic *)
logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

type unit1

type char = Zero | One

logic match_char : char, 'a, 'a -> 'a

axiom match_char_Zero :
  (forall z:'a. forall z1:'a. (match_char(Zero, z, z1) = z))

axiom match_char_One :
  (forall z:'a. forall z1:'a. (match_char(One, z, z1) = z1))

type regexp

logic Empty : regexp

logic Epsilon : regexp

logic Char : char -> regexp

logic Alt : regexp, regexp -> regexp

logic Concat : regexp, regexp -> regexp

logic Star : regexp -> regexp

logic match_regexp : regexp, 'a, 'a, 'a, 'a, 'a, 'a -> 'a

axiom match_regexp_Empty :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. (match_regexp(Empty, z, z1, z2, z3, z4, z5) = z))

axiom match_regexp_Epsilon :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. (match_regexp(Epsilon, z, z1, z2, z3, z4, z5) = z1))

axiom match_regexp_Char :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall u:char. (match_regexp(Char(u), z, z1, z2, z3, z4,
  z5) = z2))

axiom match_regexp_Alt :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall u:regexp. forall u1:regexp. (match_regexp(Alt(u, u1),
  z, z1, z2, z3, z4, z5) = z3))

axiom match_regexp_Concat :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall u:regexp. forall u1:regexp. (match_regexp(Concat(u,
  u1), z, z1, z2, z3, z4, z5) = z4))

axiom match_regexp_Star :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall u:regexp. (match_regexp(Star(u), z, z1, z2, z3, z4,
  z5) = z5))

logic index_regexp : regexp -> int

axiom index_regexp_Empty : (index_regexp(Empty) = 0)

axiom index_regexp_Epsilon : (index_regexp(Epsilon) = 1)

axiom index_regexp_Char :
  (forall u:char [Char(u)]. (index_regexp(Char(u)) = 2))

axiom index_regexp_Alt :
  (forall u:regexp. forall u1:regexp [Alt(u, u1)]. (index_regexp(Alt(u,
  u1)) = 3))

axiom index_regexp_Concat :
  (forall u:regexp. forall u1:regexp [Concat(u, u1)]. (index_regexp(Concat(u,
  u1)) = 4))

axiom index_regexp_Star :
  (forall u:regexp [Star(u)]. (index_regexp(Star(u)) = 5))

logic Char_proj_1 : regexp -> char

axiom Char_proj_1_def : (forall u:char. (Char_proj_1(Char(u)) = u))

logic Alt_proj_1 : regexp -> regexp

axiom Alt_proj_1_def :
  (forall u:regexp. forall u1:regexp. (Alt_proj_1(Alt(u, u1)) = u))

logic Alt_proj_2 : regexp -> regexp

axiom Alt_proj_2_def :
  (forall u:regexp. forall u1:regexp. (Alt_proj_2(Alt(u, u1)) = u1))

logic Concat_proj_1 : regexp -> regexp

axiom Concat_proj_1_def :
  (forall u:regexp. forall u1:regexp. (Concat_proj_1(Concat(u, u1)) = u))

logic Concat_proj_2 : regexp -> regexp

axiom Concat_proj_2_def :
  (forall u:regexp. forall u1:regexp. (Concat_proj_2(Concat(u, u1)) = u1))

logic Star_proj_1 : regexp -> regexp

axiom Star_proj_1_def : (forall u:regexp. (Star_proj_1(Star(u)) = u))

axiom regexp_inversion :
  (forall u:regexp. ((((((u = Empty) or (u = Epsilon)) or
  (u = Char(Char_proj_1(u)))) or (u = Alt(Alt_proj_1(u), Alt_proj_2(u)))) or
  (u = Concat(Concat_proj_1(u), Concat_proj_2(u)))) or
  (u = Star(Star_proj_1(u)))))

type 'a list

logic Nil : 'a list

logic Cons : 'a, 'a list -> 'a list

logic match_list : 'a list, 'a1, 'a1 -> 'a1

axiom match_list_Nil :
  (forall z:'a. forall z1:'a. (match_list((Nil : 'a1 list), z, z1) = z))

axiom match_list_Cons :
  (forall z:'a. forall z1:'a. forall u:'a1. forall u1:'a1 list.
  (match_list(Cons(u, u1), z, z1) = z1))

logic index_list : 'a list -> int

axiom index_list_Nil : (index_list((Nil : 'a list)) = 0)

axiom index_list_Cons :
  (forall u:'a. forall u1:'a list [Cons(u, u1)]. (index_list(Cons(u,
  u1)) = 1))

logic Cons_proj_1 : 'a list -> 'a

axiom Cons_proj_1_def :
  (forall u:'a. forall u1:'a list. (Cons_proj_1(Cons(u, u1)) = u))

logic Cons_proj_2 : 'a list -> 'a list

axiom Cons_proj_2_def :
  (forall u:'a. forall u1:'a list. (Cons_proj_2(Cons(u, u1)) = u1))

axiom list_inversion :
  (forall u:'a list. ((u = (Nil : 'a list)) or (u = Cons(Cons_proj_1(u),
  Cons_proj_2(u)))))

logic infix_plpl : 'a list, 'a list -> 'a list

axiom infix_plpl_def :
  (forall l2:'a list. (infix_plpl((Nil : 'a list), l2) = l2))

axiom infix_plpl_def1 :
  (forall l2:'a list.
  (forall x:'a. forall x1:'a list. (infix_plpl(Cons(x, x1), l2) = Cons(x,
  infix_plpl(x1, l2)))))

axiom Append_assoc :
  (forall l1:'a list. forall l2:'a list. forall l3:'a list. (infix_plpl(l1,
  infix_plpl(l2, l3)) = infix_plpl(infix_plpl(l1, l2), l3)))

axiom Append_l_nil : (forall l:'a list. (infix_plpl(l, (Nil : 'a list)) = l))

axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

logic length : 'a list -> int

axiom length_def : (length((Nil : 'a list)) = 0)

axiom length_def1 :
  (forall x:'a. forall x1:'a list. (length(Cons(x, x1)) = (1 + length(x1))))

axiom Length_nonnegative : (forall l:'a list. (0 <= length(l)))

axiom Length_nil :
  (forall l:'a list. ((length(l) = 0) -> (l = (Nil : 'a list))))

axiom Length_nil1 :
  (forall l:'a list. ((l = (Nil : 'a list)) -> (length(l) = 0)))

axiom Append_length :
  (forall l1:'a list. forall l2:'a list. (length(infix_plpl(l1,
  l2)) = (length(l1) + length(l2))))

logic mem : 'a, 'a list -> prop

axiom mem_def : (forall x:'a. (not mem(x, (Nil : 'a list))))

axiom mem_def1 :
  (forall x:'a.
  (forall x1:'a. forall x2:'a list. (mem(x, Cons(x1, x2)) -> ((x = x1) or
  mem(x, x2)))))

axiom mem_def2 :
  (forall x:'a.
  (forall x1:'a. forall x2:'a list. (((x = x1) or mem(x, x2)) -> mem(x,
  Cons(x1, x2)))))

axiom mem_append :
  (forall x:'a. forall l1:'a list. forall l2:'a list. (mem(x, infix_plpl(l1,
  l2)) -> (mem(x, l1) or mem(x, l2))))

axiom mem_append1 :
  (forall x:'a. forall l1:'a list. forall l2:'a list. ((mem(x, l1) or mem(x,
  l2)) -> mem(x, infix_plpl(l1, l2))))

axiom mem_decomp :
  (forall x:'a. forall l:'a list. (mem(x, l) ->
  (exists l1:'a list. exists l2:'a list. (l = infix_plpl(l1, Cons(x, l2))))))

type word

logic mem1 : char list, regexp -> prop

axiom mem_eps : mem1((Nil : char list), Epsilon)

axiom mem_char : (forall c:char. mem1(Cons(c, (Nil : char list)), Char(c)))

axiom mem_altl :
  (forall w:char list. forall r1:regexp. forall r2:regexp. (mem1(w, r1) ->
  mem1(w, Alt(r1, r2))))

axiom mem_altr :
  (forall w:char list. forall r1:regexp. forall r2:regexp. (mem1(w, r2) ->
  mem1(w, Alt(r1, r2))))

axiom mem_concat :
  (forall w1:char list. forall w2:char list. forall r1:regexp.
  forall r2:regexp. (mem1(w1, r1) -> (mem1(w2, r2) -> mem1(infix_plpl(w1,
  w2), Concat(r1, r2)))))

axiom mems1 : (forall r:regexp. mem1((Nil : char list), Star(r)))

axiom mems2 :
  (forall w1:char list. forall w2:char list. forall r:regexp. (mem1(w1, r) ->
  (mem1(w2, Star(r)) -> mem1(infix_plpl(w1, w2), Star(r)))))

axiom mem_inversion :
  (forall z:char list. forall z1:regexp. (mem1(z, z1) ->
  ((((((((z = (Nil : char list)) and (z1 = Epsilon)) or
  (exists c:char. ((z = Cons(c, (Nil : char list))) and (z1 = Char(c))))) or
  (exists w:char list. exists r1:regexp. exists r2:regexp. (mem1(w, r1) and
  ((z = w) and (z1 = Alt(r1, r2)))))) or
  (exists w:char list. exists r1:regexp. exists r2:regexp. (mem1(w, r2) and
  ((z = w) and (z1 = Alt(r1, r2)))))) or
  (exists w1:char list. exists w2:char list. exists r1:regexp.
  exists r2:regexp. (mem1(w1, r1) and (mem1(w2, r2) and ((z = infix_plpl(w1,
  w2)) and (z1 = Concat(r1, r2))))))) or
  (exists r:regexp. ((z = (Nil : char list)) and (z1 = Star(r))))) or
  (exists w1:char list. exists w2:char list. exists r:regexp. (mem1(w1,
  r) and (mem1(w2, Star(r)) and ((z = infix_plpl(w1, w2)) and
  (z1 = Star(r)))))))))

type 'a option

logic None : 'a option

logic Some : 'a -> 'a option

logic match_option : 'a option, 'a1, 'a1 -> 'a1

axiom match_option_None :
  (forall z:'a. forall z1:'a. (match_option((None : 'a1 option), z, z1) = z))

axiom match_option_Some :
  (forall z:'a. forall z1:'a. forall u:'a1. (match_option(Some(u), z,
  z1) = z1))

logic index_option : 'a option -> int

axiom index_option_None : (index_option((None : 'a option)) = 0)

axiom index_option_Some :
  (forall u:'a [Some(u)]. (index_option(Some(u)) = 1))

logic Some_proj_1 : 'a option -> 'a

axiom Some_proj_1_def : (forall u:'a. (Some_proj_1(Some(u)) = u))

axiom option_inversion :
  (forall u:'a option. ((u = (None : 'a option)) or
  (u = Some(Some_proj_1(u)))))

type stream = { state : char list
}

goal nil_notin_r1 : (not mem1((Nil : char list), Concat(Star(Alt(Char(Zero),
  Char(One))), Char(One))))

