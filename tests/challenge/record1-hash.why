(* this is a prelude for Alt-Ergo*)
(* this is a prelude for Alt-Ergo integer arithmetic *)
logic infix_eq : 'a, 'a -> prop

type tuple0 =
Tuple0

type unit1

type qtmark

logic at : 'a, qtmark -> 'a

logic old : 'a1 -> 'a1

type bool1 = True|
False

logic match_bool : bool, 'a2, 'a2 -> 'a2

axiom match_bool_True :
  (forall z:'a2. forall z1:'a2. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

function andb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, true,
  false), false)

function orb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  true, false))

function xorb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, false,
  true), match_bool(x, true, false))

function notb(x: bool) : bool = match_bool(x, false, true)

function implb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  false, true))

type 'a option

logic None : 'a option

logic Some : 'a -> 'a option

logic match_option : 'a option, 'a1, 'a1 -> 'a1

axiom match_option_None :
  (forall z:'a1. forall z1:'a1. (match_option(None, z, z1) = z))

axiom match_option_Some :
  (forall z:'a. forall z1:'a. forall u:'a1. (match_option(Some(u), z,
  z1) = z1))

logic index_option : 'a option -> int

axiom index_option_None : (index_option(None) = 0)

axiom index_option_Some :
  (forall u:'a [Some(u)]. (index_option(Some(u)) = 1))

logic Some_proj_1 : 'a option -> 'a

axiom Some_proj_1_def : (forall u:'a. (Some_proj_1(Some(u)) = u))

axiom option_inversion :
  (forall u:'a option. ((u = None) or (u = Some(Some_proj_1(u)))))

logic infix_ls : int, int -> prop

logic infix_lseq : int, int -> prop

logic ac infix_pl : int, int -> int

logic prefix_mn : int -> int

logic ac infix_as : int, int -> int

logic infix_mn : int, int -> int

axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

logic abs : int -> int

axiom abs_def : (forall x:int. ((0 <= x) -> (abs(x) = x)))

axiom abs_def1 : (forall x:int. ((not (0 <= x)) -> (abs(x) = (-x))))

axiom Abs_le : (forall x:int. forall y:int. ((abs(x) <= y) -> ((-y) <= x)))

axiom Abs_le1 : (forall x:int. forall y:int. ((abs(x) <= y) -> (x <= y)))

axiom Abs_le2 :
  (forall x:int. forall y:int. ((((-y) <= x) and (x <= y)) -> (abs(x) <= y)))

axiom Abs_pos : (forall x:int. (0 <= abs(x)))

logic div : int, int -> int

logic mod : int, int -> int

axiom Div_mod :
  (forall x:int. forall y:int. ((not (y = 0)) -> (x = ((y * div(x,
  y)) + mod(x, y)))))

axiom Div_bound :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> (0 <= div(x, y))))

axiom Div_bound1 :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> (div(x, y) <= x)))

axiom Mod_bound :
  (forall x:int. forall y:int. ((not (y = 0)) -> ((-abs(y)) <  mod(x, y))))

axiom Mod_bound1 :
  (forall x:int. forall y:int. ((not (y = 0)) -> (mod(x, y) <  abs(y))))

axiom Div_sign_pos :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> (0 <= div(x, y))))

axiom Div_sign_neg :
  (forall x:int. forall y:int. (((x <= 0) and (0 <  y)) -> (div(x, y) <= 0)))

axiom Mod_sign_pos :
  (forall x:int. forall y:int. (((0 <= x) and (not (y = 0))) -> (0 <= mod(x,
  y))))

axiom Mod_sign_neg :
  (forall x:int. forall y:int. (((x <= 0) and (not (y = 0))) -> (mod(x,
  y) <= 0)))

axiom Rounds_toward_zero :
  (forall x:int. forall y:int. ((not (y = 0)) -> (abs((div(x,
  y) * y)) <= abs(x))))

axiom Div_1 : (forall x:int. (div(x, 1) = x))

axiom Mod_1 : (forall x:int. (mod(x, 1) = 0))

axiom Div_inf :
  (forall x:int. forall y:int. (((0 <= x) and (x <  y)) -> (div(x, y) = 0)))

axiom Mod_inf :
  (forall x:int. forall y:int. (((0 <= x) and (x <  y)) -> (mod(x, y) = x)))

axiom Div_mult :
  (forall x:int. forall y:int. forall z:int [div(((x * y) + z), x)].
  (((0 <  x) and ((0 <= y) and (0 <= z))) -> (div(((x * y) + z),
  x) = (y + div(z, x)))))

axiom Mod_mult :
  (forall x:int. forall y:int. forall z:int [mod(((x * y) + z), x)].
  (((0 <  x) and ((0 <= y) and (0 <= z))) -> (mod(((x * y) + z), x) = mod(z,
  x))))

logic get : ('a,'b) farray, 'a -> 'b

logic set : ('a1,'b1) farray, 'a1, 'b1 -> ('a1,'b1) farray

logic const : 'b2 -> ('a2,'b2) farray

axiom Const : (forall b:'b3. forall a:'a3. ((const(b)[a]) = b))

type 'a list

logic Nil : 'a list

logic Cons : 'a, 'a list -> 'a list

logic match_list : 'a list, 'a1, 'a1 -> 'a1

axiom match_list_Nil :
  (forall z:'a1. forall z1:'a1. (match_list(Nil, z, z1) = z))

axiom match_list_Cons :
  (forall z:'a. forall z1:'a. forall u:'a1. forall u1:'a1 list.
  (match_list(Cons(u, u1), z, z1) = z1))

logic index_list : 'a list -> int

axiom index_list_Nil : (index_list(Nil) = 0)

axiom index_list_Cons :
  (forall u:'a. forall u1:'a list [Cons(u, u1)]. (index_list(Cons(u,
  u1)) = 1))

logic Cons_proj_1 : 'a list -> 'a

axiom Cons_proj_1_def :
  (forall u:'a. forall u1:'a list. (Cons_proj_1(Cons(u, u1)) = u))

logic Cons_proj_2 : 'a list -> 'a list

axiom Cons_proj_2_def :
  (forall u:'a. forall u1:'a list. (Cons_proj_2(Cons(u, u1)) = u1))

axiom list_inversion :
  (forall u:'a list. ((u = Nil) or (u = Cons(Cons_proj_1(u),
  Cons_proj_2(u)))))

logic mem : 'a, 'a list -> prop

axiom mem_def : (forall x:'a. (not mem(x, Nil)))

axiom mem_def1 :
  (forall x:'a.
  (forall x1:'a. forall x2:'a list. (mem(x, Cons(x1, x2)) -> ((x = x1) or
  mem(x, x2)))))

axiom mem_def2 :
  (forall x:'a.
  (forall x1:'a. forall x2:'a list. (((x = x1) or mem(x, x2)) -> mem(x,
  Cons(x1, x2)))))

type 'a array1 = { length : int; elts : (int,'a) farray
}

function get1(a: 'a1 array1, i: int) : 'a1 = ((a).elts[i])

function set1(a: 'a array1, i: int, v: 'a) : 'a array1 = { length =
  (a).length; elts = ((a).elts[i <- v]) }

type ('a, 'a1) tuple2 = { Tuple2_proj_1 : 'a; Tuple2_proj_2 : 'a1
}

type ('a2, 'b) t = { contents : ('a2,'b option) farray; data : ('a2,
'b) tuple2 list array1
}

function get2(h: ('a3, 'b1) t, k: 'a3) : 'b1 option = ((h).contents[k])

logic hash : 'a -> int

function idx(h: ('a1, 'b) t, k: 'a1) : int = mod(abs(hash(k)),
  ((h).data).length)

logic occurs_first : 'a, 'b, ('a, 'b) tuple2 list -> prop

axiom occurs_first_def :
  (forall k:'a. forall v:'b. (not occurs_first(k, v, Nil)))

axiom occurs_first_def1 :
  (forall k:'a. forall v:'b.
  (forall x:('a, 'b) tuple2. forall x1:('a, 'b) tuple2 list.
  (forall x2:'a. forall x3:'b. ((x = { Tuple2_proj_1 = x2; Tuple2_proj_2 = x3
  }) -> (occurs_first(k, v, Cons(x, x1)) -> (((k = x2) and (v = x3)) or
  ((not (k = x2)) and occurs_first(k, v, x1))))))))

axiom occurs_first_def2 :
  (forall k:'a. forall v:'b.
  (forall x:('a, 'b) tuple2. forall x1:('a, 'b) tuple2 list.
  (forall x2:'a. forall x3:'b. ((x = { Tuple2_proj_1 = x2; Tuple2_proj_2 = x3
  }) -> ((((k = x2) and (v = x3)) or ((not (k = x2)) and occurs_first(k, v,
  x1))) -> occurs_first(k, v, Cons(x, x1)))))))

axiom mem_occurs_first :
  (forall k:'a. forall v:'b. forall l:('a, 'b) tuple2 list. (occurs_first(k,
  v, l) -> mem({ Tuple2_proj_1 = k; Tuple2_proj_2 = v }, l)))

axiom cons_occurs_first :
  (forall k1:'a. forall v1:'b. forall l:('a, 'b) tuple2 list.
  (occurs_first(k1, v1, l) ->
  (forall k:'a. forall v:'b. ((not (k = k1)) -> occurs_first(k1, v1, Cons({
  Tuple2_proj_1 = k; Tuple2_proj_2 = v }, l))))))

predicate valid(h: ('a, 'b) t) = ((0 <  ((h).data).length) and
  ((forall k:'a. forall v:'b. ((get2(h, k) = Some(v)) <-> occurs_first(k, v,
   get1((h).data, idx(h, k))))) and
  (forall k:'a. forall v:'b.
  (forall i:int. (((0 <= i) and (i <  ((h).data).length)) -> (mem({
  Tuple2_proj_1 = k; Tuple2_proj_2 = v }, get1((h).data, i)) -> (i = idx(h,
  k))))))))

axiom idx_bounds1 :
  (forall h:('a, 'b) t. (valid(h) -> (forall k:'a. (0 <= idx(h, k)))))

axiom idx_bounds2 :
  (forall h:('a, 'b) t. (valid(h) ->
  (forall k:'a. (idx(h, k) <  ((h).data).length))))

goal WP_parameter_find :
  (forall h:int.
  (forall k:'a.
  (forall rho:(int,('a, 'b) tuple2 list) farray.
  (forall rho1:('a,'b option) farray. (valid({ contents = rho1; data = {
  length = h; elts = rho } }) -> (((0 <= mod(abs(hash(k)), h)) and
  (mod(abs(hash(k)), h) <  h)) ->
  (forall result:'b. (occurs_first(k, result, (rho[mod(abs(hash(k)), h)])) ->
  ((rho1[k]) = Some(result))))))))))

