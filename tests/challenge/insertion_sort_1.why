(* this is a prelude for Alt-Ergo*)
(* this is a prelude for Alt-Ergo integer arithmetic *)
axiom tuple0_inversion : (forall u:unit. (u = void))

type unit1

type qtmark

logic at : 'a, qtmark -> 'a

logic old : 'a -> 'a

logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

logic index_bool : bool -> int

axiom index_bool_True : (index_bool(true) = 0)

axiom index_bool_False : (index_bool(false) = 1)

axiom bool_inversion : (forall u:bool. ((u = true) or (u = false)))

function andb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, true,
  false), false)

function orb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  true, false))

function xorb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, false,
  true), match_bool(x, true, false))

function notb(x: bool) : bool = match_bool(x, false, true)

function implb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  false, true))

axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

type 'a ref

logic mk_ref : 'a -> 'a ref

logic mk_ref_proj_1 : 'a ref -> 'a

axiom mk_ref_proj_1_def : (forall u:'a. (mk_ref_proj_1(mk_ref(u)) = u))

axiom ref_inversion : (forall u:'a ref. (u = mk_ref(mk_ref_proj_1(u))))

function contents(u: 'a ref) : 'a = mk_ref_proj_1(u)

logic const : 'b -> ('a,'b) farray

axiom Const : (forall b:'b. forall a:'a. ((const(b)[a]) = b))

type 'a array1

logic mk_array : int, (int,'a) farray -> 'a array1

logic mk_array_proj_1 : 'a array1 -> int

axiom mk_array_proj_1_def :
  (forall u:int. forall u1:(int,'a) farray. (mk_array_proj_1(mk_array(u,
  u1)) = u))

logic mk_array_proj_2 : 'a array1 -> (int,'a) farray

axiom mk_array_proj_2_def :
  (forall u:int. forall u1:(int,'a) farray. (mk_array_proj_2(mk_array(u,
  u1)) = u1))

axiom array_inversion :
  (forall u:'a array1. (u = mk_array(mk_array_proj_1(u),
  mk_array_proj_2(u))))

function elts(u: 'a array1) : (int,'a) farray = mk_array_proj_2(u)

function length(u: 'a array1) : int = mk_array_proj_1(u)

function get(a: 'a array1, i: int) : 'a = (elts(a)[i])

function set(a: 'a array1, i: int, v: 'a) : 'a array1 =
  mk_array(mk_array_proj_1(a), (elts(a)[i <- v]))

predicate sorted_sub(a: (int,int) farray, l: int, u: int) =
  (forall i1:int. forall i2:int. ((((l <= i1) and (i1 <= i2)) and
  (i2 <  u)) -> ((a[i1]) <= (a[i2]))))

predicate sorted_sub1(a: int array1, l: int, u: int) = sorted_sub(elts(a), l,
  u)

predicate sorted(a: int array1) = sorted_sub(elts(a), 0, length(a))

predicate map_eq_sub(a1: (int,'a) farray, a2: (int,'a) farray, l: int,
  u: int) = (forall i:int. (((l <= i) and (i <  u)) -> ((a1[i]) = (a2[i]))))

predicate exchange(a1: (int,'a) farray, a2: (int,'a) farray, i: int,
  j: int) = (((a1[i]) = (a2[j])) and (((a2[i]) = (a1[j])) and
  (forall k:int. (((not (k = i)) and (not (k = j))) -> ((a1[k]) = (a2[k]))))))

axiom exchange_set :
  (forall a:(int,'a) farray.
  (forall i:int. forall j:int. exchange(a, ((a[i <- (a[j])])[j <- (a[i])]),
  i, j)))

logic permut_sub : (int,'a) farray, (int,'a) farray, int, int -> prop

axiom permut_refl :
  (forall a1:(int,'a) farray. forall a2:(int,'a) farray.
  (forall l:int. forall u:int. (map_eq_sub(a1, a2, l, u) -> permut_sub(a1,
  a2, l, u))))

axiom permut_sym :
  (forall a1:(int,'a) farray. forall a2:(int,'a) farray.
  (forall l:int. forall u:int. (permut_sub(a1, a2, l, u) -> permut_sub(a2,
  a1, l, u))))

axiom permut_trans :
  (forall a1:(int,'a) farray. forall a2:(int,'a) farray.
  forall a3:(int,'a) farray.
  (forall l:int. forall u:int. (permut_sub(a1, a2, l, u) -> (permut_sub(a2,
  a3, l, u) -> permut_sub(a1, a3, l, u)))))

axiom permut_exchange :
  (forall a1:(int,'a) farray. forall a2:(int,'a) farray.
  (forall l:int. forall u:int. forall i:int. forall j:int. (((l <= i) and
  (i <  u)) -> (((l <= j) and (j <  u)) -> (exchange(a1, a2, i, j) ->
  permut_sub(a1, a2, l, u))))))

axiom permut_sub_inversion :
  (forall z:(int,'a) farray. forall z1:(int,'a) farray. forall z2:int.
  forall z3:int. (permut_sub(z, z1, z2, z3) ->
  ((((exists a1:(int,'a) farray. exists a2:(int,'a) farray.
     (exists l:int. exists u:int. (map_eq_sub(a1, a2, l, u) and
     ((((z = a1) and (z1 = a2)) and (z2 = l)) and (z3 = u))))) or
  (exists a1:(int,'a) farray. exists a2:(int,'a) farray.
  (exists l:int. exists u:int. (permut_sub(a1, a2, l, u) and ((((z = a2) and
  (z1 = a1)) and (z2 = l)) and (z3 = u)))))) or
  (exists a1:(int,'a) farray. exists a2:(int,'a) farray.
  exists a3:(int,'a) farray.
  (exists l:int. exists u:int. (permut_sub(a1, a2, l, u) and (permut_sub(a2,
  a3, l, u) and ((((z = a1) and (z1 = a3)) and (z2 = l)) and (z3 = u))))))) or
  (exists a1:(int,'a) farray. exists a2:(int,'a) farray.
  (exists l:int. exists u:int. exists i:int. exists j:int. (((l <= i) and
  (i <  u)) and (((l <= j) and (j <  u)) and (exchange(a1, a2, i, j) and
  ((((z = a1) and (z1 = a2)) and (z2 = l)) and (z3 = u))))))))))

axiom permut_weakening :
  (forall a1:(int,'a) farray. forall a2:(int,'a) farray.
  (forall l1:int. forall r1:int. forall l2:int. forall r2:int.
  ((((l1 <= l2) and (l2 <= r2)) and (r2 <= r1)) -> (permut_sub(a1, a2, l2,
  r2) -> permut_sub(a1, a2, l1, r1)))))

axiom permut_eq :
  (forall a1:(int,'a) farray. forall a2:(int,'a) farray.
  (forall l:int. forall u:int. (permut_sub(a1, a2, l, u) ->
  (forall i:int. (((i <  l) or (u <= i)) -> ((a2[i]) = (a1[i])))))))

axiom permut_exists :
  (forall a1:(int,'a) farray. forall a2:(int,'a) farray.
  (forall l:int. forall u:int. (permut_sub(a1, a2, l, u) ->
  (forall i:int. (((l <= i) and (i <  u)) ->
  (exists j:int. (((l <= j) and (j <  u)) and ((a2[i]) = (a1[j])))))))))

predicate exchange1(a1: 'a array1, a2: 'a array1, i: int, j: int) =
  exchange(elts(a1), elts(a2), i, j)

predicate permut_sub1(a1: 'a array1, a2: 'a array1, l: int, u: int) =
  permut_sub(elts(a1), elts(a2), l, u)

predicate permut(a1: 'a array1, a2: 'a array1) =
  ((length(a1) = length(a2)) and permut_sub(elts(a1), elts(a2), 0,
  length(a1)))

axiom exchange_permut :
  (forall a1:'a array1. forall a2:'a array1. forall i:int. forall j:int
  [exchange1(a1, a2, i, j)]. (exchange1(a1, a2, i, j) ->
  ((length(a1) = length(a2)) -> (((0 <= i) and (i <  length(a1))) ->
  (((0 <= j) and (j <  length(a1))) -> permut(a1, a2))))))

axiom permut_sym1 :
  (forall a1:'a array1. forall a2:'a array1. (permut(a1, a2) -> permut(a2,
  a1)))

axiom permut_trans1 :
  (forall a1:'a array1. forall a2:'a array1. forall a3:'a array1. (permut(a1,
  a2) -> (permut(a2, a3) -> permut(a1, a3))))

predicate array_eq_sub(a1: 'a array1, a2: 'a array1, l: int, u: int) =
  map_eq_sub(elts(a1), elts(a2), l, u)

predicate array_eq(a1: 'a array1, a2: 'a array1) =
  ((length(a1) = length(a2)) and array_eq_sub(a1, a2, 0, length(a1)))

axiom array_eq_sub_permut :
  (forall a1:'a array1. forall a2:'a array1. forall l:int. forall u:int.
  (array_eq_sub(a1, a2, l, u) -> permut_sub1(a1, a2, l, u)))

axiom array_eq_permut :
  (forall a1:'a array1. forall a2:'a array1. (array_eq(a1, a2) -> permut(a1,
  a2)))

goal WP_parameter_insertion_sort :
  (forall a:int.
  (forall a1:(int,int) farray. ((1 <= (a - 1)) ->
  (forall a2:(int,int) farray.
  (forall i:int. (((1 <= i) and (i <= (a - 1))) -> ((sorted_sub(a2, 0, i) and
  permut(mk_array(a, a1), mk_array(a, a2))) -> (((0 <= i) and (i <  a)) ->
  (forall j:int.
  (forall a3:(int,int) farray. ((((0 <= j) and (j <= i)) and
  (permut(mk_array(a, a1), set(mk_array(a, a3), j, (a2[i]))) and
  ((forall k1:int. forall k2:int. ((((0 <= k1) and (k1 <= k2)) and
   (k2 <= i)) -> ((not (k1 = j)) -> ((not (k2 = j)) ->
   ((a3[k1]) <= (a3[k2])))))) and
  (forall k:int. ((((j + 1) <= k) and (k <= i)) -> ((a2[i]) <  (a3[k]))))))) ->
  ((0 <  j) -> (((0 <= (j - 1)) and ((j - 1) <  a)) ->
  (((a2[i]) <  (a3[(j - 1)])) -> (((0 <= (j - 1)) and ((j - 1) <  a)) ->
  (((0 <= j) and (j <  a)) ->
  (forall a4:(int,int) farray. ((a4 = (a3[j <- (a3[(j - 1)])])) ->
  (exchange(mk_array_proj_2(set(mk_array(a, a3), j, (a2[i]))),
  mk_array_proj_2(set(mk_array(a, a4), (j - 1), (a2[i]))), (j - 1), j) ->
  (forall j1:int. ((j1 = (j - 1)) ->
  (forall k:int. ((((j1 + 1) <= k) and (k <= i)) -> ((a2[i]) <  (a4[k])))))))))))))))))))))))))

