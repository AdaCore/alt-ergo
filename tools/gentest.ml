(* This file is free software, part of dolmen. See file "LICENSE" for more information *)

module File = struct
  (* Test if the file exists. *)
  let exists file =
    match open_in file with
    | _ -> true
    | exception Sys_error _ -> false

  (* Scan recursively a directory. *)
  let scan_folder path =
    let handle = Unix.opendir path in
    let rec aux files folders h =
      match Unix.readdir h with
      | exception End_of_file ->
        Unix.closedir h;
        List.sort String.compare files,
        List.sort String.compare folders
      | "." | ".." ->
        aux files folders h
      | s ->
        let f = Filename.concat path s in
        let stat = Unix.stat f in
        begin match stat.st_kind with
          | Unix.S_REG -> aux (s :: files) folders h
          | Unix.S_DIR -> aux files (s :: folders) h
          | _ -> aux files folders h
        end
    in
    aux [] [] handle

  let read_all ch =
    let buf = Buffer.create 113 in
    try
      while true do
        Buffer.add_channel buf ch 30
      done;
      assert false
    with End_of_file ->
      Buffer.contents buf

  let diff file1 file2 =
    let cmd = Format.asprintf "diff %s %s" file1 file2 in
    let ch = Unix.open_process_in cmd in
    let res = read_all ch in
    ignore (Unix.close_process_in ch);
    res

  let contains pattern file =
    let cmd = Format.asprintf {|grep -q "%s" %s|} pattern file 
    in
    let ch = Unix.open_process_in cmd in
    let _ = read_all ch in
    let res = Unix.close_process_in ch in
    match res with
    | Unix.WEXITED 0 -> true
    | _ -> false
  
  let touch file contents =
    if Sys.file_exists file then
      true
    else
      let ch = open_out file in
      output_string ch contents;
      close_out ch;
      false

  let cat fmt file =
    let ch = open_in file in
    try while true do
      let s = input_line ch in
      Format.fprintf fmt "%s@\n" s
    done
    with End_of_file ->
    Format.fprintf fmt "@."

  let is_empty file =
    let ch = open_in file in
    let res = 
      try
        let _ = input_char ch in
      false
    with End_of_file -> true in
    close_in ch;
    res

  let is_a_problem file =
    match Filename.extension file with
    | ".ae"
    | ".smt2"
    | ".psmt2"
    | ".zip"
      -> true
    | _
      -> false
end

type cmd = {
  bin: string;
  args: string list
}

let pp_command fmt cmd =
  let pp_sep fmt () = Format.fprintf fmt " @," in
  let pp_arg fmt = Format.fprintf fmt "%s" in
  let pp_args fmt = Format.pp_print_list ~pp_sep pp_arg fmt in
  Format.fprintf fmt "%s %a %%{input}" cmd.bin pp_args cmd.args

let digest_args args = 
  List.fold_left (fun acc arg -> arg ^ acc) "" args
  |> Digest.string
  |> Digest.to_hex 

let pp_output fmt (cmd, pb_file) =
  let filename = Filename.chop_extension pb_file in
  Format.fprintf fmt "%s_%s.output" filename (digest_args cmd.args)

let pp_expected_output fmt pb_file =
  let filename = Filename.chop_extension pb_file in
  Format.fprintf fmt "%s.expected" filename

let pp_stanza_test fmt ((cmd, pb_file) as test) =
  Format.fprintf fmt 
  "@[<v 1>\
  (rule@ \
    (target %a)@ \
    (deps (:input %s))@ \
    (package alt-ergo-lib)@ \
      @[<v 1>(action@ \
        @[<v 1>(chdir %%{workspace_root}@ \
          @[<v 1>(with-stdout-to %%{target}@ \
            @[<v 1>(with-accepted-exit-codes 0@ \
              @[<v 1>(run %a))))))@]@]@]@]@]@]@\n\
@[<v 1>(rule@ \
  @[<v 1>(alias runtest)@ \
  @[<v 1>(package alt-ergo-lib)@ \
  @[<v 1>(action (diff %a @, %a)))@]@]@]@]@."
  pp_output test
  pb_file
  pp_command cmd
  pp_expected_output pb_file
  pp_output test 
  
let generate_test cmds pb_file =
  List.fold_left (fun acc cmd -> 
    (cmd, pb_file) :: acc
  ) [] cmds

let generate_tests cmds pb_files =
  List.fold_left (fun acc pb_file -> 
    generate_test cmds pb_file @ acc
  ) [] pb_files
 
let pp_stanza_batch fmt cmds pb_files =
  let open Format in
  let tests = generate_tests cmds pb_files in
  fprintf fmt "; File auto-generated by gentests@\n@\n";
  fprintf fmt "; Auto-generated part begin@\n";
  let pp_sep fmt () = fprintf fmt "@\n" in
  pp_print_list ~pp_sep pp_stanza_test fmt tests; 
  fprintf fmt "; Auto-generated part end@."

type ctx = {
  mutable path: string;
  mutable new_counter: int;
  mutable update_counter: int;
  mutable total_counter: int;
}

let generate_dune_file ctx cmds pb_files =
  ctx.total_counter <- ctx.total_counter + 1;
  let dune_filename = Filename.concat ctx.path "dune" in
  let is_new = not @@ File.exists dune_filename in
  let old_digest = 
    if not is_new then 
      Digest.file dune_filename 
    else ""
  in
  let ch = open_out dune_filename in 
  let fmt = Format.formatter_of_out_channel ch in
  pp_stanza_batch fmt cmds pb_files;
  let is_update = 
    not (Digest.file dune_filename 
    |> Digest.equal old_digest)
  in
  if is_update then (
    ctx.update_counter <- ctx.update_counter + 1
  );
  if is_new || is_update then (
    ctx.new_counter <- ctx.new_counter + 1;
    pp_stanza_batch Format.std_formatter cmds pb_files
  );
  close_out ch;
  ctx

let rec generate_dune_rec ctx cmds =
  let files, folders = File.scan_folder ctx.path in
  let ctx = match List.filter File.is_a_problem files with
  | [] -> ctx
  | pb_files -> (
    generate_dune_file ctx cmds pb_files
  ) in
  List.iter (fun path ->
    ctx.path <- path;
    generate_dune_rec ctx cmds
  ) (List.map (Filename.concat ctx.path) folders)
 
let () = 
  let bin = "alt-ergo" in
  let basic_args = [
      "--output=smtlib2"
    ; "--timelimit=1" ] 
  in
  let args = [
      [] 
    ; ["--no-minimal-bj"] 
    ; ["--no-tableaux-cdcl-in-theories"]
    ; [
      "--no-tableaux-cdcl-in-theories"
    ; "--dsat"]
    ; [
      "--no-minimal-bj" 
    ; "--no-tableaux-cdcl-in-theories"
    ; "--dsat"]]
  in
  let ctx = {
    path = if Array.length Sys.argv >= 2 then 
      Sys.argv.(1) 
    else "."; 
    new_counter = 0; 
    update_counter = 0; 
    total_counter = 0
  } in
  List.rev_map (fun args -> 
    { bin; args = basic_args @ args }
  ) args 
  |> generate_dune_rec ctx; 
  Format.printf "%i %i %i\n" 
    ctx.new_counter ctx.update_counter ctx.total_counter

